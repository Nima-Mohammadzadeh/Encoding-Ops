############################################################
# File: config.py
############################################################
import os
import json

SERIALS_CSV_PATH = r"Z:\3 Encoding and Printing Files\SERIALS_CSV_PATH.csv"
SETTINGS_JSON = r"settings_config.json"
DEFAULT_SETTINGS = {
    "inlay_types": ["Tageos EOS-300", "Avery AD-237", "Impinj MR6-P"],
    "label_sizes": ["2 x 1", "3 x 1", "4 x 2"]
}



############################################################
# File: database_tab.py
############################################################
# database_tab.py
from PyQt6.QtWidgets import *
import os
import pandas as pd

class DatabaseTab(QWidget):
    def __init__(self, job):
        super().__init__()
        self.job = job
        layout = QVBoxLayout()
        self.info_label = QLabel("No database present.\nClick below to generate a new EPC database.")
        layout.addWidget(self.info_label)
        self.gen_btn = QPushButton("Generate Database File")
        self.gen_btn.clicked.connect(self.handle_generate_db)
        layout.addWidget(self.gen_btn)
        self.setLayout(layout)

    def handle_generate_db(self):
        job_folder = getattr(self.job, 'folder_path', None)
        if not job_folder:
            QMessageBox.warning(self, "Error", "No job folder found.")
            return
        data_folder = os.path.join(job_folder, "Data")
        os.makedirs(data_folder, exist_ok=True)
        db_path = os.path.join(data_folder, "EPC_Database.xlsx")
        # Change the columns as needed for your project:
        df = pd.DataFrame(columns=["EPC", "Serial", "UPC", "Date"])
        df.to_excel(db_path, index=False)
        QMessageBox.information(self, "Database Created", f"Database saved at:\n{db_path}")
        self.info_label.setText(f"Database created at: {db_path}")



############################################################
# File: extract_all_code.py
############################################################
#extract_all_code.py
import os

# Set the root directory (change this if necessary)
ROOT_DIR = os.path.abspath(os.path.dirname(__file__))

# List to store tuples of (file_path, code_text)
py_files_code = []

# Walk through the project directory tree
for foldername, subfolders, files in os.walk(ROOT_DIR):
    for filename in files:
        if filename.endswith('.py'):
            file_path = os.path.join(foldername, filename)
            # Read file content
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    code = f.read()
            except UnicodeDecodeError:
                with open(file_path, 'r', encoding='latin1') as f:
                    code = f.read()
            rel_path = os.path.relpath(file_path, ROOT_DIR)
            py_files_code.append((rel_path, code))

# Output to stdout (you can redirect to a file if you wish)
for rel_path, code in py_files_code:
    print('#' * 60)
    print(f'# File: {rel_path}')
    print('#' * 60)
    print(code)
    print('\n\n')



############################################################
# File: extract_label_sizes.py
############################################################
#!/usr/bin/env python3
"""
extract_label_sizes.py

Usage:
  python extract_label_sizes.py root_directory -o output.txt

This script traverses each customer folder under the given root directory,
collects subfolder names that represent label sizes (e.g., '1.85 x .91'),
rounds dimensions to two decimal places, removes duplicates, and writes
the sorted list to the output text file.
"""

import os
import re
import argparse

def extract_sizes(root_dir):
    sizes = set()
    # Loop over each customer directory
    for customer in os.listdir(root_dir):
        cust_path = os.path.join(root_dir, customer)
        if not os.path.isdir(cust_path):
            continue
        # Loop over subdirectories inside each customer folder
        for item in os.listdir(cust_path):
            size_path = os.path.join(cust_path, item)
            if os.path.isdir(size_path):
                # Extract numeric parts from the folder name
                parts = re.findall(r"[0-9]*\.?[0-9]+", item)
                if len(parts) >= 2:
                    try:
                        w = round(float(parts[0]), 2)
                        h = round(float(parts[1]), 2)
                        sizes.add(f"{w:.2f} x {h:.2f}")
                    except ValueError:
                        continue
    return sizes

def main():
    parser = argparse.ArgumentParser(description="Extract unique label sizes from directory structure.")
    parser.add_argument('root', help="Root directory containing customer folders.")
    parser.add_argument('-o', '--output', default='label_sizes.txt', help="Output text file path.")
    args = parser.parse_args()

    sizes = extract_sizes(args.root)
    # Sort by numeric width then height
    sorted_sizes = sorted(
        sizes,
        key=lambda s: tuple(map(float, re.findall(r"[0-9]*\.?[0-9]+", s)))
    )

    with open(args.output, 'w', encoding='utf-8') as f:
        for size in sorted_sizes:
            f.write(size + '\n')

    print(f"Extracted {len(sorted_sizes)} unique sizes to {args.output}")

if __name__ == '__main__':
    main()




############################################################
# File: main.py
############################################################
import sys
import random
from PyQt6.QtWidgets import QApplication, QMainWindow, QTabWidget

from ui.dashboard import DashboardWidget
from ui.jobs_module import JobsModuleWidget
from ui.reports import ReportsWidget
from ui.settings import SettingsWidget

from util import current_time_str


class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("RFID Workflow Management Suite")
        self.resize(1000, 700)
        # Printer data (mock, globally shared)
        self.printer_data = {}
        for i in range(1, 11):
            pid = f"p{str(i).zfill(2)}"
            base_pass = 10 * random.randint(1, 5)
            self.printer_data[pid] = {
                "printer_id": pid,
                "pass_count": base_pass,
                "fail_count": random.randint(0, base_pass // 2),
                "last_event": current_time_str()
            }
        tabs = QTabWidget()
        tabs.addTab(DashboardWidget(self.printer_data), "Dashboard")
        tabs.addTab(JobsModuleWidget(), "Jobs")
        tabs.addTab(ReportsWidget(), "Reports")
        tabs.addTab(SettingsWidget(self.printer_data), "Settings")
        self.setCentralWidget(tabs)

def main():
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())

if __name__ == '__main__':
    main()



############################################################
# File: merge_encoding_ops.py
############################################################
#!/usr/bin/env python3
"""
merge_encoding_ops.py

Usage:
  python merge_encoding_ops.py

This script merges a predefined list of Python files for the Encoding Room OPS
project into a single text file, with separators indicating each file name.
"""
import os

# List of Python files to merge
FILE_PATHS = [
    r"C:\Users\Encoding 3\Desktop\Encoding Room OPS\jobs_module.py",
    r"C:\Users\Encoding 3\Desktop\Encoding Room OPS\main.py",
    r"C:\Users\Encoding 3\Desktop\Encoding Room OPS\module_selector.py",
    r"C:\Users\Encoding 3\Desktop\Encoding Room OPS\reports.py",
    r"C:\Users\Encoding 3\Desktop\Encoding Room OPS\roll_tracker.py",
    r"C:\Users\Encoding 3\Desktop\Encoding Room OPS\settings.py",
    r"C:\Users\Encoding 3\Desktop\Encoding Room OPS\test_print.py",
    r"C:\Users\Encoding 3\Desktop\Encoding Room OPS\util.py",
    r"C:\Users\Encoding 3\Desktop\Encoding Room OPS\bartender_step.py",
    r"C:\Users\Encoding 3\Desktop\Encoding Room OPS\config.py",
    r"C:\Users\Encoding 3\Desktop\Encoding Room OPS\dashboard.py",
    r"C:\Users\Encoding 3\Desktop\Encoding Room OPS\database_generator.py",
    r"C:\Users\Encoding 3\Desktop\Encoding Room OPS\docs_export.py",
    r"C:\Users\Encoding 3\Desktop\Encoding Room OPS\encoding_checklist.py",
    r"C:\Users\Encoding 3\Desktop\Encoding Room OPS\jobdata.py"
]

# Output file name
OUTPUT_PATH = "merged_encoding_ops.txt"

def merge_files(paths, output):
    with open(output, 'w', encoding='utf-8') as out_file:
        for path in paths:
            filename = os.path.basename(path)
            out_file.write(f"# === File: {filename} ===\n")
            try:
                with open(path, 'r', encoding='utf-8') as in_file:
                    out_file.write(in_file.read())
            except Exception as e:
                out_file.write(f"# Error reading {filename}: {e}\n")
            out_file.write("\n\n")

def main():
    merge_files(FILE_PATHS, OUTPUT_PATH)
    print(f"Merged {len(FILE_PATHS)} files into {OUTPUT_PATH}")

if __name__ == "__main__":
    main()




############################################################
# File: rrr.py
############################################################
#!/usr/bin/env python3
import tkinter as tk
from tkinter import filedialog, messagebox, BooleanVar, ttk
import traceback
import os, sys
from pathlib import Path
from math import ceil
from datetime import date
from pypdf import PdfReader, PdfWriter
from pypdf.generic import NameObject, BooleanObject, TextStringObject

# Constants for grouping
DETAIL_KEYS = {'customer','part_num','job_ticket','customer_po','inlay_type','label_size','layout','start','stop','upc','item'}
CONFIG_KEYS = {'qty','lpr','rolls','overage','production_qty','label_type'}

# Label type previews
LABEL_PREVIEWS = {
    "Type A": "previews/type_a.png",
    "Type B": "previews/type_b.png",
    "Type C": "previews/type_c.png",
}

class DynamicPDFFormFiller(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("PDF Form Filler")
        self.geometry("700x700")
        self.pdf_path = tk.StringVar()
        self.field_vars = {}    # normalized_key -> tk.Variable
        self.pdf_map    = {}    # normalized_key -> actual PDF field name
        self.preview_photo = None
        self.row = {'details':0,'config':0,'checks':0,'misc':0}

        # File picker
        picker = tk.Frame(self)
        picker.pack(fill="x", padx=10, pady=(10,0))
        tk.Label(picker, text="Template PDF:").pack(side="left")
        tk.Entry(picker, textvariable=self.pdf_path).pack(side="left", fill="x", expand=True, padx=5)
        tk.Button(picker, text="Browse…", command=self.browse_pdf).pack(side="right")

        # Notebook for sections
        self.notebook = ttk.Notebook(self)
        self.frame_details = ttk.Frame(self.notebook)
        self.frame_config  = ttk.Frame(self.notebook)
        self.frame_checks  = ttk.Frame(self.notebook)
        self.frame_misc    = ttk.Frame(self.notebook)
        self.notebook.add(self.frame_details, text="Details")
        self.notebook.add(self.frame_config,  text="Config")
        self.notebook.add(self.frame_checks,  text="Approvals")
        self.notebook.add(self.frame_misc,    text="Misc")
        self.notebook.pack(fill="both", expand=True, padx=10, pady=10)

        # Save button
        self.save_btn = tk.Button(self, text="Save & Fill PDF", command=self.save_filled)
        self.save_btn.pack(pady=(0,10))

    def browse_pdf(self):
        path = filedialog.askopenfilename(filetypes=[("PDF","*.pdf")])
        if not path:
            return
        self.pdf_path.set(path)
        self.load_fields(path)

    def load_fields(self, path):
        # clear previous
        for frame in (self.frame_details, self.frame_config, self.frame_checks, self.frame_misc):
            for w in frame.winfo_children():
                w.destroy()
        self.field_vars.clear()
        self.pdf_map.clear()
        for k in self.row:
            self.row[k] = 0

        reader = PdfReader(path)
        fields = reader.get_fields() or {}
        if not fields:
            messagebox.showerror("No Fields",
                "PDF has no form fields. Export with 'Create PDF form'.")
            return

        for name, info in fields.items():
            norm = name.lower()
            ftype = info.get("/FT")
            # select frame & group
            if norm in DETAIL_KEYS:
                frame, grp = self.frame_details, 'details'
            elif norm in CONFIG_KEYS:
                frame, grp = self.frame_config, 'config'
            elif ftype == "/Btn":
                frame, grp = self.frame_checks, 'checks'
            else:
                frame, grp = self.frame_misc,   'misc'
            r = self.row[grp]

            # label
            lbl = tk.Label(frame, text=name)
            lbl.grid(row=r, column=0, sticky='w', padx=5, pady=3)

            # variable & widget
            if norm == 'qty':
                var = tk.IntVar(value=0)
                ent = tk.Entry(frame, textvariable=var)
                ent.grid(row=r, column=1, sticky='ew', padx=5)
                var.trace_add('write', lambda *a: self._recalc())

            elif norm == 'lpr':
                var = tk.IntVar(value=1)
                ent = tk.Entry(frame, textvariable=var)
                ent.grid(row=r, column=1, sticky='ew', padx=5)
                var.trace_add('write', lambda *a: self._recalc())

            elif norm == 'rolls':
                var = tk.IntVar(value=0)
                ent = tk.Entry(frame, textvariable=var, state='readonly')
                ent.grid(row=r, column=1, sticky='ew', padx=5)

            elif norm == 'overage':
                var = tk.DoubleVar(value=0.0)
                sb = tk.Spinbox(frame, from_=0, to=100, textvariable=var, width=5)
                sb.grid(row=r, column=1, sticky='w', padx=5)
                tk.Label(frame, text="%").grid(row=r, column=2, sticky='w')
                var.trace_add('write', lambda *a: self._recalc())

            elif norm == 'production_qty':
                var = tk.IntVar(value=0)
                ent = tk.Entry(frame, textvariable=var, state='readonly')
                ent.grid(row=r, column=1, sticky='ew', padx=5)

            elif norm == 'date':
                var = tk.StringVar(value=date.today().isoformat())
                ent = tk.Entry(frame, textvariable=var, state='readonly')
                ent.grid(row=r, column=1, sticky='ew', padx=5)

            elif norm == 'label_type':
                var = tk.StringVar(value=list(LABEL_PREVIEWS.keys())[0])
                om = tk.OptionMenu(frame, var, *LABEL_PREVIEWS.keys(), command=self._update_preview)
                om.grid(row=r, column=1, sticky='ew', padx=5)
                self.preview_label = tk.Label(frame)
                self.preview_label.grid(row=r+1, column=0, columnspan=3)
                self._update_preview(var.get())

            elif ftype == "/Btn":
                var = BooleanVar(value=False)
                cb = tk.Checkbutton(frame, variable=var)
                cb.grid(row=r, column=1, sticky='w', padx=5)

            else:
                var = tk.StringVar()
                ent = tk.Entry(frame, textvariable=var)
                ent.grid(row=r, column=1, sticky='ew', padx=5)

            # expand column
            frame.grid_columnconfigure(1, weight=1)
            # store
            self.field_vars[norm] = var
            self.pdf_map[norm] = name
            # next row
            self.row[grp] += 2 if norm=='label_type' else 1

    def _recalc(self):
        try:
            q   = self.field_vars['qty'].get()
            l   = self.field_vars['lpr'].get() or 1
            ov  = self.field_vars['overage'].get()/100.0
            rolls = ceil(q/l)
            self.field_vars['rolls'].set(rolls)
            prod  = int(q + q*ov)
            self.field_vars['production_qty'].set(prod)
        except:
            pass

    def _update_preview(self, choice):
        path = LABEL_PREVIEWS.get(choice)
        if path and Path(path).exists():
            img = tk.PhotoImage(file=path)
            self.preview_photo = img
            self.preview_label.config(image=img)
        else:
            self.preview_label.config(image='')

    def save_filled(self):
        tpl = self.pdf_path.get()
        if not tpl:
            messagebox.showwarning("Missing", "Select a PDF first.")
            return
        data = {}
        for norm, var in self.field_vars.items():
            val = var.get()
            if isinstance(var, BooleanVar):
                data[self.pdf_map[norm]] = "Yes" if val else "Off"
            else:
                data[self.pdf_map[norm]] = str(val)
        out = Path(tpl).with_name(f"{Path(tpl).stem}_filled.pdf")
        try:
            self.fill_pdf(tpl, data, str(out))
            # open file
            if sys.platform.startswith('win'):
                os.startfile(str(out))
            elif sys.platform.startswith('darwin'):
                os.system(f'open "{out}"')
            else:
                os.system(f'xdg-open "{out}"')
        except Exception as e:
            traceback.print_exc()
            messagebox.showerror("Error", f"{type(e).__name__}: {e}")

    @staticmethod
    def fill_pdf(input_pdf, data_dict, output_pdf):
        reader = PdfReader(input_pdf)
        writer = PdfWriter()
        writer.append_pages_from_reader(reader)
        root = reader.trailer['/Root']
        if '/AcroForm' in root:
            acro = root['/AcroForm']
            writer._root_object.update({NameObject('/AcroForm'): acro})
            writer._root_object['/AcroForm'].update({NameObject('/NeedAppearances'): BooleanObject(True)})
            # bump font size
            old_da = acro.get(NameObject('/DA'), '')
            try:
                parts = old_da.split()
                font, size, *_ = parts
                new_da = f"{font} {int(size)+1} Tf {' '.join(parts[3:])}"
            except:
                new_da = '/Helv 12 Tf 0 g'
            writer._root_object['/AcroForm'].update({NameObject('/DA'): TextStringObject(new_da)})
        for page in writer.pages:
            writer.update_page_form_field_values(page, data_dict)
            if '/Annots' in page:
                for ann in page['/Annots']:
                    annot = ann.get_object()
                    if annot.get('/Subtype')=='/Widget' and annot.get('/T') in data_dict:
                        val = data_dict[annot['/T']]
                        ap  = annot.get('/AP',{}).get('/N',{})
                        if isinstance(ap, dict):
                            on = [k for k in ap.keys() if k != '/Off']
                            if on:
                                annot.update({NameObject('/AS'): NameObject(on[0] if val!='Off' else '/Off')})
        with open(output_pdf,'wb') as f:
            writer.write(f)

if __name__ == '__main__':
    DynamicPDFFormFiller().mainloop()




############################################################
# File: Testing.py
############################################################
import sys, random, datetime
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QStackedWidget, QVBoxLayout, QHBoxLayout,
    QLabel, QPushButton, QLineEdit, QFormLayout, QMessageBox, QFileDialog,
    QTabWidget, QProgressBar, QListWidget, QComboBox, QToolBar, QDialog,
    QScrollArea, QCheckBox, QTableWidget, QTableWidgetItem, QHeaderView
)
from PyQt6.QtGui import QAction, QFont
from PyQt6.QtCore import Qt, QTimer

# ---------------------------
# Utility: formatted current time
# ---------------------------
def current_time_str():
    return datetime.datetime.now().strftime("%H:%M:%S")

# ---------------------------
# Printer Detail Dialog
# ---------------------------
class PrinterDetailDialog(QDialog):
    """Displays additional details for a printer."""
    def __init__(self, printer_data):
        super().__init__()
        self.setWindowTitle(f"Details for {printer_data['printer_id']}")
        self.resize(400, 300)
        layout = QVBoxLayout()
        # Display printer name and cumulative counts
        layout.addWidget(QLabel(f"Printer Name: {printer_data['printer_id']}"))
        printed = printer_data["pass_count"] + printer_data["fail_count"]
        layout.addWidget(QLabel(f"Total Printed: {printed}"))
        layout.addWidget(QLabel(f"Total Voided: {printer_data['fail_count']}"))
        if printed > 0:
            error_pct = f"{(printer_data['fail_count']/printed * 100):.1f}%"
        else:
            error_pct = "0%"
        layout.addWidget(QLabel(f"Quality Error %: {error_pct}"))
        layout.addWidget(QLabel(f"Last Update: {printer_data['last_event']}"))
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        layout.addWidget(close_btn)
        self.setLayout(layout)

# ---------------------------
# Refined Dashboard / Live Monitor Widget
# ---------------------------
class DashboardWidget(QWidget):
    def __init__(self, printer_data):
        super().__init__()
        self.all_printers = printer_data  # Shared dictionary

        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(10)

        # Header with title and time interval selector
        header_layout = QHBoxLayout()
        header_label = QLabel("Dashboard / Live Monitor")
        header_label.setStyleSheet("font-size: 16px; font-weight: bold;")
        header_layout.addWidget(header_label)
        header_layout.addStretch()
        self.interval_selector = QComboBox()
        self.interval_selector.addItems(["Live", "1 hour", "4 hours", "8 hours"])
        header_layout.addWidget(QLabel("Interval:"))
        header_layout.addWidget(self.interval_selector)
        main_layout.addLayout(header_layout)

        # Table for printer display
        self.table = QTableWidget()
        self.table.setColumnCount(4)
        self.table.setHorizontalHeaderLabels(["Printer", "Printed", "Voided", "Error %"])
        self.table.verticalHeader().setVisible(False)
        self.table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        # Increase font size for readability
        font = QFont()
        font.setPointSize(11)
        self.table.setFont(font)
        # Stretch columns to fill available width
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        # Increase row height for better space utilization
        self.table.verticalHeader().setDefaultSectionSize(30)
        # Connect double-click to open detail dialog
        self.table.cellDoubleClicked.connect(self.handle_row_click)
        main_layout.addWidget(self.table)

        self.setLayout(main_layout)
        self.populate_table()

        # Timer to simulate streaming updates every 2-5 seconds
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_table_data)
        self.reset_timer()

    def reset_timer(self):
        interval = random.randint(2000, 5000)
        self.timer.start(interval)

    def generate_mock_printer(self, printer_id):
        base_pass = 10 * random.randint(1, 5)
        return {
            "printer_id": printer_id,
            "pass_count": base_pass,
            "fail_count": random.randint(0, base_pass // 2),
            "last_event": current_time_str()
        }

    def populate_table(self):
        printers = sorted(self.all_printers.keys())
        self.table.setRowCount(len(printers))
        for idx, pid in enumerate(printers):
            data = self.all_printers[pid]
            printed = data["pass_count"] + data["fail_count"]
            voided = data["fail_count"]
            error_pct = f"{(voided/printed * 100):.1f}%" if printed > 0 else "0%"
            self.table.setItem(idx, 0, QTableWidgetItem(pid))
            self.table.setItem(idx, 1, QTableWidgetItem(str(printed)))
            self.table.setItem(idx, 2, QTableWidgetItem(str(voided)))
            self.table.setItem(idx, 3, QTableWidgetItem(error_pct))

    def update_table_data(self):
        interval = self.interval_selector.currentText()
        multiplier = {"Live": 1, "1 hour": 1, "4 hours": 2, "8 hours": 3}.get(interval, 1)
        for pid in self.all_printers:
            data = self.all_printers[pid]
            data["pass_count"] += random.randint(0, 5 * multiplier)
            data["fail_count"] += random.randint(0, 3 * multiplier)
            data["last_event"] = current_time_str()
        self.populate_table()
        self.reset_timer()

    def handle_row_click(self, row, column):
        pid_item = self.table.item(row, 0)
        if pid_item:
            pid = pid_item.text()
            printer_data = self.all_printers.get(pid)
            if printer_data:
                dlg = PrinterDetailDialog(printer_data)
                dlg.exec()

# ---------------------------
# Printer Settings Widget (for the Settings -> Printers tab)
# ---------------------------
class PrinterSettingsWidget(QWidget):
    def __init__(self, printer_data):
        super().__init__()
        self.printer_data = printer_data  # Shared dictionary

        layout = QVBoxLayout()
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)

        # Table to display and edit printer names
        self.table = QTableWidget()
        self.table.setColumnCount(1)
        self.table.setHorizontalHeaderLabels(["Printer Name"])
        self.table.verticalHeader().setVisible(False)
        self.table.setEditTriggers(QTableWidget.EditTrigger.DoubleClicked | 
                                    QTableWidget.EditTrigger.SelectedClicked)
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        layout.addWidget(self.table)

        # Controls to add a new printer
        add_layout = QHBoxLayout()
        self.new_printer_edit = QLineEdit()
        self.new_printer_edit.setPlaceholderText("New printer name")
        add_layout.addWidget(self.new_printer_edit)
        add_btn = QPushButton("Add Printer")
        add_btn.clicked.connect(self.add_printer)
        add_layout.addWidget(add_btn)
        layout.addLayout(add_layout)

        # Button to delete selected printer(s)
        del_btn = QPushButton("Delete Selected")
        del_btn.clicked.connect(self.delete_selected)
        layout.addWidget(del_btn)

        # Button to save changes
        save_btn = QPushButton("Save Changes")
        save_btn.clicked.connect(self.save_changes)
        layout.addWidget(save_btn)

        self.setLayout(layout)
        self.populate_table()

    def populate_table(self):
        printers = sorted(self.printer_data.keys())
        self.table.setRowCount(len(printers))
        for idx, pid in enumerate(printers):
            item = QTableWidgetItem(pid)
            item.setFlags(item.flags() | Qt.ItemFlag.ItemIsEditable)
            self.table.setItem(idx, 0, item)

    def add_printer(self):
        name = self.new_printer_edit.text().strip()
        if name:
            if name in self.printer_data:
                QMessageBox.warning(self, "Duplicate", "Printer already exists.")
            else:
                # Add new printer with default settings
                self.printer_data[name] = {"printer_id": name,
                                           "pass_count": 0,
                                           "fail_count": 0,
                                           "last_event": current_time_str()}
                self.populate_table()
                self.new_printer_edit.clear()

    def delete_selected(self):
        selected = self.table.selectedItems()
        if selected:
            for item in selected:
                pid = item.text()
                if pid in self.printer_data:
                    del self.printer_data[pid]
            self.populate_table()

    def save_changes(self):
        # Update printer names based on the current table values
        new_data = {}
        for row in range(self.table.rowCount()):
            item = self.table.item(row, 0)
            if item:
                new_name = item.text().strip()
                if new_name:
                    # Preserve existing data if printer already exists, else create defaults.
                    if new_name in self.printer_data:
                        new_data[new_name] = self.printer_data[new_name]
                    else:
                        new_data[new_name] = {"printer_id": new_name,
                                              "pass_count": 0,
                                              "fail_count": 0,
                                              "last_event": current_time_str()}
        self.printer_data.clear()
        self.printer_data.update(new_data)
        QMessageBox.information(self, "Saved", "Printer settings updated.")

# ---------------------------
# Settings Widget
# ---------------------------
class SettingsWidget(QWidget):
    def __init__(self, printer_data):
        super().__init__()
        tabs = QTabWidget()
        # File Locations Tab remains unchanged
        file_tab = QWidget()
        file_layout = QFormLayout()
        file_layout.addRow("CSV File Path:", QLineEdit("Z:\\Path\\to\\csv_data.csv"))
        file_layout.addRow("Template Folder:", QLineEdit("Z:\\Path\\to\\templates"))
        file_tab.setLayout(file_layout)
        tabs.addTab(file_tab, "File Locations")
        # Replace static printer tab with interactive PrinterSettingsWidget
        printer_tab = PrinterSettingsWidget(printer_data)
        tabs.addTab(printer_tab, "Printers")
        # Roles Tab remains unchanged
        roles_tab = QWidget()
        roles_layout = QVBoxLayout()
        roles_layout.addWidget(QLabel("User Roles (stubbed)"))
        roles_tab.setLayout(roles_layout)
        tabs.addTab(roles_tab, "User Roles")
        theme_btn = QPushButton("Toggle Dark/Light Theme")
        theme_btn.clicked.connect(lambda: QMessageBox.information(self, "Theme", "Theme toggled (mock)."))
        layout = QVBoxLayout()
        layout.addWidget(tabs)
        layout.addWidget(theme_btn)
        self.setLayout(layout)

# ---------------------------
# Ticket / Job Entry
# ---------------------------
class TicketWidget(QWidget):
    def __init__(self):
        super().__init__()
        layout = QFormLayout()
        self.job_name = QLineEdit()
        self.product_code = QLineEdit()
        self.label_qty = QLineEdit()
        layout.addRow("Job Name:", self.job_name)
        layout.addRow("Product Code:", self.product_code)
        layout.addRow("Label Quantity:", self.label_qty)
        generate_btn = QPushButton("Generate Job")
        generate_btn.clicked.connect(self.generate_job)
        layout.addRow(generate_btn)
        self.setLayout(layout)

    def generate_job(self):
        if not self.job_name.text() or not self.product_code.text() or not self.label_qty.text().isdigit():
            QMessageBox.warning(self, "Validation Error", "Please enter valid job details.")
        else:
            QMessageBox.information(self, "Job Created", "Job successfully created (mock).")

# ---------------------------
# Database Generation
# ---------------------------
class DBGenerationWidget(QWidget):
    def __init__(self):
        super().__init__()
        layout = QFormLayout()
        self.start_serial = QLineEdit()
        self.quantity = QLineEdit()
        layout.addRow("Start Serial:", self.start_serial)
        layout.addRow("Quantity:", self.quantity)
        gen_btn = QPushButton("Generate DB")
        gen_btn.clicked.connect(self.generate_db)
        layout.addRow(gen_btn)
        self.setLayout(layout)

    def generate_db(self):
        if not self.start_serial.text().isdigit() or not self.quantity.text().isdigit():
            QMessageBox.warning(self, "Validation Error", "Enter numeric values only.")
        else:
            QMessageBox.information(self, "Success", "Database generated successfully (mock).")

# ---------------------------
# BarTender File Manager
# ---------------------------
class BarTenderWidget(QWidget):
    def __init__(self):
        super().__init__()
        layout = QFormLayout()
        self.template_path = QLineEdit()
        browse_template = QPushButton("Browse Template")
        browse_template.clicked.connect(self.browse_template)
        self.dest_path = QLineEdit()
        browse_dest = QPushButton("Browse Destination")
        browse_dest.clicked.connect(self.browse_dest)
        layout.addRow("Template File:", self.template_path)
        layout.addRow("", browse_template)
        layout.addRow("Destination Path:", self.dest_path)
        layout.addRow("", browse_dest)
        link_btn = QPushButton("Create/Link")
        link_btn.clicked.connect(self.link_file)
        layout.addRow(link_btn)
        self.setLayout(layout)

    def browse_template(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select .btw Template", "", "BarTender Files (*.btw)")
        if path:
            self.template_path.setText(path)

    def browse_dest(self):
        path = QFileDialog.getExistingDirectory(self, "Select Destination Folder")
        if path:
            self.dest_path.setText(path)

    def link_file(self):
        QMessageBox.information(self, "Success", "BarTender file linked successfully (mock).")

# ---------------------------
# Test Print & Verification
# ---------------------------
class TestPrintWidget(QWidget):
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout()
        print_btn = QPushButton("Print 5 Labels")
        print_btn.clicked.connect(self.print_labels)
        layout.addWidget(print_btn)
        self.result_list = QListWidget()
        layout.addWidget(self.result_list)
        signoff_btn = QPushButton("Digital Sign-Off")
        signoff_btn.clicked.connect(self.sign_off)
        layout.addWidget(signoff_btn)
        self.setLayout(layout)

    def print_labels(self):
        self.result_list.clear()
        for i in range(5):
            self.result_list.addItem(f"Label {i+1}: EPC XYZ{100+i} - PASS")
        QMessageBox.information(self, "Test Print", "Test print completed (mock).")

    def sign_off(self):
        QMessageBox.information(self, "Sign-Off", "Test print verified and signed off (mock).")

# ---------------------------
# Roll Tracker
# ---------------------------
class RollTrackerWidget(QWidget):
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout()
        layout.addWidget(QLabel("Roll Tracker"))
        for roll in range(1, 3):
            bar = QProgressBar()
            bar.setValue(50)
            layout.addWidget(QLabel(f"Roll {roll}"))
            layout.addWidget(bar)
        pdf_btn = QPushButton("Print to PDF")
        pdf_btn.clicked.connect(lambda: QMessageBox.information(self, "Print", "Export to PDF (mock)."))
        layout.addWidget(pdf_btn)
        self.setLayout(layout)

# ---------------------------
# Reports & Logs
# ---------------------------
class ReportsWidget(QWidget):
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout()
        filter_layout = QHBoxLayout()
        filter_layout.addWidget(QLabel("Filter by Job/Date:"))
        self.filter_input = QLineEdit()
        filter_layout.addWidget(self.filter_input)
        layout.addLayout(filter_layout)
        csv_btn = QPushButton("Download CSV")
        csv_btn.clicked.connect(lambda: QMessageBox.information(self, "Download", "CSV downloaded (mock)."))
        pdf_btn = QPushButton("Download PDF")
        pdf_btn.clicked.connect(lambda: QMessageBox.information(self, "Download", "PDF downloaded (mock)."))
        layout.addWidget(csv_btn)
        layout.addWidget(pdf_btn)
        self.setLayout(layout)

# ---------------------------
# Main Navigation Shell
# ---------------------------
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("RFID Workflow Management App Prototype")
        self.resize(1000, 700)

        # Create a shared printer data store
        self.printer_data = {}
        for i in range(1, 16):
            pid = f"p{str(i).zfill(2)}"
            # Initialize with default mock data:
            base_pass = 10 * random.randint(1, 5)
            self.printer_data[pid] = {
                "printer_id": pid,
                "pass_count": base_pass,
                "fail_count": random.randint(0, base_pass // 2),
                "last_event": current_time_str()
            }

        toolbar = QToolBar("Main Navigation")
        # Increase toolbar font size slightly
        font = toolbar.font()
        font.setPointSize(font.pointSize() + 4)
        toolbar.setFont(font)
        self.addToolBar(toolbar)

        self.stack = QStackedWidget()
        self.widgets = {
            "Dashboard": DashboardWidget(self.printer_data),
            "Ticket": TicketWidget(),
            "DB Generation": DBGenerationWidget(),
            "BarTender": BarTenderWidget(),
            "Test Print": TestPrintWidget(),
            "Roll Tracker": RollTrackerWidget(),
            "Reports": ReportsWidget(),
            "Settings": SettingsWidget(self.printer_data)
        }
        for name, widget in self.widgets.items():
            self.stack.addWidget(widget)
            action = QAction(name, self)
            action.triggered.connect(lambda checked, n=name: self.switch_module(n))
            toolbar.addAction(action)
        self.setCentralWidget(self.stack)
        self.switch_module("Dashboard")

    def switch_module(self, name):
        widget = self.widgets.get(name)
        if widget:
            index = self.stack.indexOf(widget)
            self.stack.setCurrentIndex(index)

# ---------------------------
# Run the Application
# ---------------------------
def main():
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())

if __name__ == '__main__':
    main()




############################################################
# File: util.py
############################################################
import os, re
import csv
import datetime
from config import SERIALS_CSV_PATH, SETTINGS_JSON, DEFAULT_SETTINGS
import json
import ast


CUSTOMERS_ROOT = r"Z:\3 Encoding and Printing Files\Customers Encoding Files"
LABEL_SIZE_ROOT = r"Z:\3 Encoding and Printing Files\Encoding Ops\label_sizes.txt"

def get_all_customers():
    return [d for d in os.listdir(CUSTOMERS_ROOT) if os.path.isdir(os.path.join(CUSTOMERS_ROOT, d))]


def _load_label_sizes(path: str = LABEL_SIZE_ROOT) -> list[str]:
    """
    Read label-size definitions from *path*.

    * If the file starts with '[' we assume it’s a literal Python list and
      parse it with ast.literal_eval().
    * Otherwise we treat it as “one label per line”.
    """
    with open(path, "r", encoding="utf-8") as fh:
        raw = fh.read().strip()

    # Case 1 – literal Python list
    if raw.startswith("[") and raw.endswith("]"):
        try:
            data = ast.literal_eval(raw)
            if isinstance(data, list):
                return [str(item).strip() for item in data if str(item).strip()]
        except (SyntaxError, ValueError):
            pass  # fallback to next case

    # Case 2 – one label per line (ALWAYS return here if not list)
    return [line.strip() for line in raw.splitlines() if line.strip()]
        
        
def get_all_label_sizes():
    """
    Returns a sorted, deduplicated list of label sizes from file.
    """
    import os
    sizes = set()
    if os.path.isfile(LABEL_SIZE_ROOT):
        with open(LABEL_SIZE_ROOT, "r", encoding="utf-8") as f:
            data = f.read()
            for entry in data.split(","):
                val = entry.strip()
                # basic validation: must look like "int x int" or "float x float"
                import re
                if re.match(r"^\d+(\.\d+)?\s*x\s*\d+(\.\d+)?$", val):
                    sizes.add(re.sub(r"\s+", " ", val))  # normalize spaces
    return sorted(sizes)



def get_inlay_types():
    # Reads from 'popular_inlays.txt' in PROJECT ROOT
    with open(r"Z:\3 Encoding and Printing Files\Encoding Ops\label_types.txt") as f:
        return [line.strip() for line in f if line.strip()]



def current_time_str():
    return datetime.datetime.now().strftime("%H:%M:%S")

def load_settings():
    if not os.path.exists(SETTINGS_JSON):
        with open(SETTINGS_JSON, "w") as f:
            json.dump(DEFAULT_SETTINGS, f, indent=2)
        return DEFAULT_SETTINGS.copy()
    with open(SETTINGS_JSON, "r") as f:
        return json.load(f)

def save_settings(data):
    with open(SETTINGS_JSON, "w") as f:
        json.dump(data, f, indent=2)

def get_latest_serial():
    try:
        with open(SERIALS_CSV_PATH, "r", newline="") as f:
            reader = csv.reader(f)
            next(reader, None)
            row = next(reader, None)
            return int(row[0]) if row and row[0].isdigit() else 1
    except Exception:
        os.makedirs(os.path.dirname(SERIALS_CSV_PATH), exist_ok=True)
        with open(SERIALS_CSV_PATH, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(['latest_serial'])
            writer.writerow(['1'])
        return 1

def update_latest_serial(new_serial):
    with open(SERIALS_CSV_PATH, "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["latest_serial"])
        writer.writerow([str(new_serial)])



############################################################
# File: data\jobdata.py
############################################################

# file: data/jobdata.py

import datetime


class JobData:
    def __init__(self, name, code, qty, modules=None):   # <--- add the modules param & default
        self.name = name
        self.code = code
        self.qty = qty
        self.start_time = datetime.datetime.now()
        self.serials = []
        self.bartender_file = ""
        self.rolls = []
        self.status = "Initialized"
        self.checklist_data = {
            'customer': '',
            'job_ticket': '',
            'part_num': '',
            'customer_po': '',
            'item': '',
            'inlay_type': '',
            'label_size': '',
            'qty': '',
            'overage': '',
            'upc': '',
            'start': '',
            'stop': '',
            'labels_per_roll': '',
            'rolls': ''
        }
        # Store module selections (add this new attribute)
        self.modules = modules or {
            "show_checklist": True,
            "show_dbgen": True,
            "show_rolltracker": True
        }



############################################################
# File: data\job_folder.py
############################################################
# file: data/job_folder.py
import os

def get_job_dir(customer, label_size, job_ticket, po, date_str):
    base_path = r"Z:\3 Encoding and Printing Files\Customers Encoding Files"
    cust_dir  = os.path.join(base_path, customer)
    size_dir  = os.path.join(cust_dir,   label_size)
    job_name  = f"{date_str} - {po} - {job_ticket}"
    return os.path.join(size_dir, job_name)

def create_job_folders(customer, label_size, job_ticket, po, date_str):
    job_dir = get_job_dir(customer, label_size, job_ticket, po, date_str)
    os.makedirs(os.path.join(job_dir, 'data'), exist_ok=True)
    os.makedirs(os.path.join(job_dir, 'print'), exist_ok=True)
    os.makedirs(os.path.join(job_dir, 'roll tracker'), exist_ok=True)
    return job_dir




############################################################
# File: data\serial_tracker.py
############################################################
# serial_tracker.py

import csv, os, datetime

SERIAL_TRACKER_CSV = r"Z:\3 Encoding and Printing Files\Operations\serial_tracker.csv"

def get_next_available_serial():
    if not os.path.exists(SERIAL_TRACKER_CSV):
        return 1
    with open(SERIAL_TRACKER_CSV, newline='', encoding='utf-8') as f:
        rdr = list(csv.DictReader(f))
        if not rdr:
            return 1
        return int(rdr[-1]['next_serial'])

def reserve_serials(job_ticket, customer, label_size, qty):
    start = get_next_available_serial()
    stop = start + qty - 1
    next_serial = stop + 1
    row = {
        "date": datetime.datetime.now().strftime('%Y-%m-%d'),
        "job_ticket": job_ticket,
        "customer": customer,
        "label_size": label_size,
        "serial_start": start,
        "serial_stop": stop,
        "next_serial": next_serial
    }
    file_exists = os.path.exists(SERIAL_TRACKER_CSV)
    with open(SERIAL_TRACKER_CSV, 'a', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, fieldnames=list(row.keys()))
        if not file_exists:
            writer.writeheader()
        writer.writerow(row)
    return (start, stop)



############################################################
# File: data\__init__.py
############################################################




############################################################
# File: ui\dashboard.py
############################################################
from PyQt6.QtWidgets import *
from PyQt6.QtGui import QFont
from PyQt6.QtCore import QTimer, Qt
from util import current_time_str
import random

# ---------- Dashboard ----------
class PrinterDetailDialog(QDialog):
    def __init__(self, printer_data):
        super().__init__()
        self.setWindowTitle(f"Details for {printer_data['printer_id']}")
        self.resize(400, 300)
        layout = QVBoxLayout()
        layout.addWidget(QLabel(f"Printer Name: {printer_data['printer_id']}"))
        printed = printer_data["pass_count"] + printer_data["fail_count"]
        layout.addWidget(QLabel(f"Total Printed: {printed}"))
        layout.addWidget(QLabel(f"Total Voided: {printer_data['fail_count']}"))
        error_pct = f"{(printer_data['fail_count']/printed * 100):.1f}%" if printed > 0 else "0%"
        layout.addWidget(QLabel(f"Quality Error %: {error_pct}"))
        layout.addWidget(QLabel(f"Last Update: {printer_data['last_event']}"))
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        layout.addWidget(close_btn)
        self.setLayout(layout)

class DashboardWidget(QWidget):
    def __init__(self, printer_data):
        super().__init__()
        self.all_printers = printer_data
        main_layout = QVBoxLayout()
        header_layout = QHBoxLayout()
        header_label = QLabel("Dashboard / Live Monitor")
        header_label.setStyleSheet("font-size: 16px; font-weight: bold;")
        header_layout.addWidget(header_label)
        header_layout.addStretch()
        self.interval_selector = QComboBox()
        self.interval_selector.addItems(["Live", "1 hour", "4 hours", "8 hours"])
        header_layout.addWidget(QLabel("Interval:"))
        header_layout.addWidget(self.interval_selector)
        main_layout.addLayout(header_layout)
        self.table = QTableWidget()
        self.table.setColumnCount(4)
        self.table.setHorizontalHeaderLabels(["Printer", "Printed", "Voided", "Error %"])
        self.table.verticalHeader().setVisible(False)
        self.table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        font = QFont()
        font.setPointSize(11)
        self.table.setFont(font)
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.table.verticalHeader().setDefaultSectionSize(30)
        self.table.cellDoubleClicked.connect(self.handle_row_click)
        main_layout.addWidget(self.table)
        self.setLayout(main_layout)
        self.populate_table()
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_table_data)
        self.timer.start(3000)
    def populate_table(self):
        printers = sorted(self.all_printers.keys())
        self.table.setRowCount(len(printers))
        for idx, pid in enumerate(printers):
            data = self.all_printers[pid]
            printed = data["pass_count"] + data["fail_count"]
            voided = data["fail_count"]
            error_pct = f"{(voided/printed * 100):.1f}%" if printed > 0 else "0%"
            self.table.setItem(idx, 0, QTableWidgetItem(pid))
            self.table.setItem(idx, 1, QTableWidgetItem(str(printed)))
            self.table.setItem(idx, 2, QTableWidgetItem(str(voided)))
            self.table.setItem(idx, 3, QTableWidgetItem(error_pct))
    def update_table_data(self):
        interval = self.interval_selector.currentText()
        multiplier = {"Live": 1, "1 hour": 1, "4 hours": 2, "8 hours": 3}.get(interval, 1)
        for pid in self.all_printers:
            data = self.all_printers[pid]
            data["pass_count"] += random.randint(0, 5 * multiplier)
            data["fail_count"] += random.randint(0, 3 * multiplier)
            data["last_event"] = current_time_str()
        self.populate_table()
    def handle_row_click(self, row, column):
        pid_item = self.table.item(row, 0)
        if pid_item:
            pid = pid_item.text()
            printer_data = self.all_printers.get(pid)
            if printer_data:
                dlg = PrinterDetailDialog(printer_data)
                dlg.exec()



############################################################
# File: ui\jobs_module.py
############################################################
# jobs_module.py
from PyQt6.QtWidgets import *

from data.jobdata import JobData
from workflow.encoding_checklist import EncodingChecklistTab
from database_tab import DatabaseTab   # new file/class below!
from workflow.database_generator import DatabaseGeneratorTab
from workflow.roll_tracker import RollTrackerStep
from workflow.bartender_step import BarTenderStep
from workflow.test_print import TestPrintStep
from workflow.docs_export import DocsExportStep
from ui.module_selector import ModuleSelectionDialog

from PyQt6.QtGui import QIntValidator
from PyQt6.QtWidgets import QComboBox, QCompleter
import os
import datetime
from util import get_all_customers, get_all_label_sizes, get_inlay_types


# --- Utility functions from above ---
from util import get_all_customers, get_all_label_sizes

CUSTOMERS_ROOT = r"Z:\3 Encoding and Printing Files\Customers Encoding Files"



def make_job_folder(customer, label_size, job_ticket, po):
    today = datetime.datetime.now().strftime("%Y-%m-%d")
    folder_name = f"{today} - {po} - {job_ticket}"
    path = os.path.join(CUSTOMERS_ROOT, customer, label_size, folder_name)
    os.makedirs(os.path.join(path, "Print"), exist_ok=True)
    os.makedirs(os.path.join(path, "Data"), exist_ok=True)
    os.makedirs(os.path.join(path, "Roll Tracker"), exist_ok=True)
    os.makedirs(os.path.join(path, "Reports"), exist_ok=True)
    os.makedirs(os.path.join(path, "Checklist"), exist_ok=True)
    return path

class JobWizard(QDialog):
    def __init__(self, data: dict = None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("New Job")
        form = QFormLayout(self)

        custs = get_all_customers()
        self.customer = QComboBox()
        self.customer.setEditable(True)
        self.customer.addItems(custs)
        self.customer.setCompleter(QCompleter(custs, self))
        form.addRow("Customer", self.customer)

        self.jobticket = QLineEdit(); form.addRow("Job Ticket", self.jobticket)
        self.partnum = QLineEdit(); form.addRow("Part Num", self.partnum)
        self.po = QLineEdit(); form.addRow("Customer PO", self.po)
        self.item = QLineEdit(); form.addRow("Item", self.item)

        inlays = get_inlay_types()
        self.inlay_type = QComboBox()
        self.inlay_type.setEditable(True)
        self.inlay_type.addItems(inlays)
        self.inlay_type.setCompleter(QCompleter(inlays, self))
        form.addRow("Inlay Type", self.inlay_type)

        all_label_sizes = get_all_label_sizes()
        self.label_size = QComboBox()
        self.label_size.setEditable(True)
        self.label_size.addItems(all_label_sizes)
        self.label_size.setCompleter(QCompleter(all_label_sizes, self))
        form.addRow("Label Size", self.label_size)

        self.qty = QLineEdit()
        self.qty.setValidator(QIntValidator(1,99999999)); form.addRow("QTY", self.qty)

        self.overage = QSpinBox()
        self.overage.setSuffix("%"); self.overage.setRange(0,100)
        form.addRow("Overage %", self.overage)

        self.upc = QLineEdit()
        self.upc.setMaxLength(15)
        self.upc.textChanged.connect(self._format_upc)
        form.addRow("UPC", self.upc)

        self.labels_per_roll = QLineEdit()
        self.labels_per_roll.setValidator(QIntValidator(1,99999999))
        self.labels_per_roll.textChanged.connect(self._calc_rolls)
        form.addRow("Labels Per Roll", self.labels_per_roll)

        self.rolls = QLabel("0")
        form.addRow("Rolls", self.rolls)

        btns = QHBoxLayout()
        done = QPushButton("Finish"); cancel = QPushButton("Cancel")
        btns.addWidget(done); btns.addWidget(cancel)
        form.addRow(btns)
        done.clicked.connect(self._finish)
        cancel.clicked.connect(self.reject)
        self.setLayout(form)

        self._result = None
        
        if data: self.fill(data)


    def _format_upc(self, txt):
        digits = "".join(c for c in txt if c.isdigit())[:12]
        pretty = ""
        for i, d in enumerate(digits):
            pretty += d
            if i in (2,5,8):
                pretty += "\u2009"
        self.upc.blockSignals(True)
        self.upc.setText(pretty)
        self.upc.blockSignals(False)
        
    def _calc_rolls(self):
        try:
            qty = int(self.qty.text())
            per = int(self.labels_per_roll.text())
            rolls = (qty + per - 1) // per
            self.rolls.setText(str(rolls))
        except:
            self.rolls.setText("0")

    def _finish(self):
        # Validate, map to dict, accept or warn
        # Map field values as per your  field names
        # (Add validation as needed)
        self.result = {
            "customer": self.customer.currentText(),
            "job_ticket": self.jobticket.text(),
            "part_num": self.partnum.text(),
            "customer_po": self.po.text(),
            "item": self.item.text(),
            "inlay_type": self.inlay_type.currentText(),
            "label_size": self.label_size.currentText(),
            "qty": int(self.qty.text().replace(",", "")),
            "overage": str(self.overage.value()),
            "upc": "".join(c for c in self.upc.text() if c.isdigit())[:12],
            "labels_per_roll": int(self.labels_per_roll.text().replace(",", "")),
            "rolls": int(self.rolls.text()),
        }
        self.accept()
        
    def get_data(self):
        return getattr(self, 'result', None)

            

class SingleJobWorkflowWidget(QWidget):
    def __init__(self, job: JobData, jobs_modwidget=None):
        super().__init__()
        layout = QVBoxLayout()
        self.tabs = QTabWidget()
        self.checklist_tab = EncodingChecklistTab(job, jobs_modwidget)
        self.tabs.addTab(self.checklist_tab, "Checklist")
        self.tabs.addTab(DatabaseTab(job), "Database")
        self.tabs.addTab(RollTrackerStep(job), "Roll Tracker")
        self.tabs.addTab(BarTenderStep(job), "BarTender")
        self.tabs.addTab(TestPrintStep(job), "Test Print & QC")
        self.tabs.addTab(DocsExportStep(job), "Docs/Export")
        layout.addWidget(self.tabs)
        self.setLayout(layout)
        

class JobsModuleWidget(QWidget):
    def __init__(self):
        super().__init__()
        split = QSplitter()
        self.job_list = QListWidget()
        self.new_btn = QPushButton("New Job")
        self.new_btn.setMaximumWidth(150)
        left_layout = QVBoxLayout()
        left_layout.addWidget(QLabel("All Jobs"))
        left_layout.addWidget(self.job_list)
        left_layout.addWidget(self.new_btn)
        left_panel = QWidget()
        left_panel.setLayout(left_layout)
        self.right_panel = QWidget()
        self.right_panel_layout = QVBoxLayout()
        self.right_panel_layout.addWidget(QLabel("No job selected."))
        self.right_panel.setLayout(self.right_panel_layout)
        split.addWidget(left_panel)
        split.addWidget(self.right_panel)
        split.setStretchFactor(1, 2)
        layout = QHBoxLayout()
        layout.addWidget(split)
        self.setLayout(layout)
        self.jobs = []
        self.job_list.currentRowChanged.connect(self.select_job)
        self.new_btn.clicked.connect(self.new_job_dialog)

    def select_job(self, row):
        if row >= 0 and row < len(self.jobs):
            job = self.jobs[row]
            while self.right_panel_layout.count():
                item = self.right_panel_layout.takeAt(0)
                w = item.widget()
                if w: w.deleteLater()
            # Provide self for edit checklist re-entry
            self.right_panel_layout.addWidget(SingleJobWorkflowWidget(job, self))
        else:
            while self.right_panel_layout.count():
                item = self.right_panel_layout.takeAt(0)
                w = item.widget()
                if w: w.deleteLater()
            self.right_panel_layout.addWidget(QLabel("No job selected."))

    def new_job_dialog(self, prefill=None):
        dlg = JobWizard(prefill, self)
        if dlg.exec() == QDialog.DialogCode.Accepted:
            data = dlg.get_data()
            if not data: return
            folder_path = make_job_folder(
                data['customer'], data['label_size'], data['job_ticket'], data['customer_po']
            )
            job_name = f"{data['customer']} - {data['job_ticket']} - {data['label_size']}"
            job = JobData(job_name, data['job_ticket'], data['qty'])
            job.checklist_data = data
            job.folder_path = folder_path
            self.jobs.append(job)
            self.job_list.addItem(job_name)
            self.job_list.setCurrentRow(len(self.jobs) - 1)
            QMessageBox.information(self, "Folder Created", f"Job folder:\n{folder_path}\nJob added.")

    def edit_job(self, job:JobData):
        self.new_job_dialog(prefill=job.checklist_data)



############################################################
# File: ui\module_selector.py
############################################################
# module_selector.py

from PyQt6.QtWidgets import QDialog, QVBoxLayout, QCheckBox, QPushButton, QHBoxLayout, QLabel

class ModuleSelectionDialog(QDialog):
    """
    Dialog asking which workflow modules to use for a new job.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Select Workflow Modules")
        layout = QVBoxLayout()
        msg = QLabel(
            "Choose which modules to use for this job.\n"
            "You can choose any combination, but at least one."
        )
        layout.addWidget(msg)
        self.cb_checklist = QCheckBox("Encoding Checklist")
        self.cb_dbgen = QCheckBox("Database Generator")
        self.cb_rolltracker = QCheckBox("Roll Tracker")
        self.cb_checklist.setChecked(True)
        self.cb_dbgen.setChecked(False)
        self.cb_rolltracker.setChecked(False)
        layout.addWidget(self.cb_checklist)
        layout.addWidget(self.cb_dbgen)
        layout.addWidget(self.cb_rolltracker)
        btn_layout = QHBoxLayout()
        ok_btn = QPushButton("Start Workflow")
        cancel_btn = QPushButton("Cancel")
        btn_layout.addWidget(ok_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        ok_btn.clicked.connect(self.accept)
        cancel_btn.clicked.connect(self.reject)

    def get_selection(self):
        return {
            "show_checklist": self.cb_checklist.isChecked(),
            "show_dbgen": self.cb_dbgen.isChecked(),
            "show_rolltracker": self.cb_rolltracker.isChecked()
        }



############################################################
# File: ui\reports.py
############################################################
from PyQt6.QtWidgets import *

class ReportsWidget(QWidget):
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout()
        filter_layout = QHBoxLayout()
        filter_layout.addWidget(QLabel("Filter by Job/Date:"))
        self.filter_input = QLineEdit()
        filter_layout.addWidget(self.filter_input)
        layout.addLayout(filter_layout)
        csv_btn = QPushButton("Download CSV")
        csv_btn.clicked.connect(lambda: QMessageBox.information(self, "Download", "CSV downloaded (mock)."))
        pdf_btn = QPushButton("Download PDF")
        pdf_btn.clicked.connect(lambda: QMessageBox.information(self, "Download", "PDF downloaded (mock)."))
        layout.addWidget(csv_btn)
        layout.addWidget(pdf_btn)
        self.setLayout(layout)



############################################################
# File: ui\settings.py
############################################################
from PyQt6.QtWidgets import *
from PyQt6.QtCore import Qt
from util import load_settings, save_settings, current_time_str
SETTINGS_DATA = load_settings()

class PrinterSettingsWidget(QWidget):
    def __init__(self, printer_data):
        super().__init__()
        self.printer_data = printer_data
        layout = QVBoxLayout()
        self.table = QTableWidget()
        self.table.setColumnCount(1)
        self.table.setHorizontalHeaderLabels(["Printer Name"])
        self.table.verticalHeader().setVisible(False)
        self.table.setEditTriggers(QTableWidget.EditTrigger.DoubleClicked |
                                    QTableWidget.EditTrigger.SelectedClicked)
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        layout.addWidget(self.table)
        add_layout = QHBoxLayout()
        self.new_printer_edit = QLineEdit()
        self.new_printer_edit.setPlaceholderText("New printer name")
        add_layout.addWidget(self.new_printer_edit)
        add_btn = QPushButton("Add Printer")
        add_btn.clicked.connect(self.add_printer)
        add_layout.addWidget(add_btn)
        layout.addLayout(add_layout)
        del_btn = QPushButton("Delete Selected")
        del_btn.clicked.connect(self.delete_selected)
        layout.addWidget(del_btn)
        save_btn = QPushButton("Save Changes")
        save_btn.clicked.connect(self.save_changes)
        layout.addWidget(save_btn)
        self.setLayout(layout)
        self.populate_table()
    def populate_table(self):
        printers = sorted(self.printer_data.keys())
        self.table.setRowCount(len(printers))
        for idx, pid in enumerate(printers):
            item = QTableWidgetItem(pid)
            item.setFlags(item.flags() | Qt.ItemFlag.ItemIsEditable)
            self.table.setItem(idx, 0, item)
    def add_printer(self):
        name = self.new_printer_edit.text().strip()
        if name:
            if name in self.printer_data:
                QMessageBox.warning(self, "Duplicate", "Printer already exists.")
            else:
                self.printer_data[name] = {"printer_id": name,
                                           "pass_count": 0,
                                           "fail_count": 0,
                                           "last_event": current_time_str()}
                self.populate_table()
                self.new_printer_edit.clear()
    def delete_selected(self):
        selected = self.table.selectedItems()
        if selected:
            for item in selected:
                pid = item.text()
                if pid in self.printer_data:
                    del self.printer_data[pid]
            self.populate_table()
    def save_changes(self):
        new_data = {}
        for row in range(self.table.rowCount()):
            item = self.table.item(row, 0)
            if item:
                new_name = item.text().strip()
                if new_name:
                    if new_name in self.printer_data:
                        new_data[new_name] = self.printer_data[new_name]
                    else:
                        new_data[new_name] = {"printer_id": new_name,
                                              "pass_count": 0,
                                              "fail_count": 0,
                                              "last_event": current_time_str()}
        self.printer_data.clear()
        self.printer_data.update(new_data)
        QMessageBox.information(self, "Saved", "Printer settings updated.")

class InlayTypeSettingsWidget(QWidget):
    def __init__(self, settings_data):
        super().__init__()
        self.settings_data = settings_data
        layout = QVBoxLayout()
        self.list_widget = QListWidget()
        self.refresh_list()
        layout.addWidget(QLabel("Inlay Types:"))
        layout.addWidget(self.list_widget)
        edit_layout = QHBoxLayout()
        self.new_input = QLineEdit()
        edit_layout.addWidget(self.new_input)
        add_btn = QPushButton("Add")
        add_btn.clicked.connect(self.add_item)
        edit_layout.addWidget(add_btn)
        layout.addLayout(edit_layout)
        edit_rename_layout = QHBoxLayout()
        self.rename_input = QLineEdit()
        edit_rename_layout.addWidget(self.rename_input)
        rename_btn = QPushButton("Rename")
        rename_btn.clicked.connect(self.rename_item)
        edit_rename_layout.addWidget(rename_btn)
        del_btn = QPushButton("Delete")
        del_btn.clicked.connect(self.delete_selected)
        edit_rename_layout.addWidget(del_btn)
        layout.addLayout(edit_rename_layout)
        self.setLayout(layout)
        self.list_widget.currentRowChanged.connect(self.select_item)
    def refresh_list(self):
        self.list_widget.clear()
        self.list_widget.addItems(self.settings_data["inlay_types"])
    def add_item(self):
        name = self.new_input.text().strip()
        if name and name not in self.settings_data["inlay_types"]:
            self.settings_data["inlay_types"].append(name)
            save_settings(self.settings_data)
            self.refresh_list()
            self.new_input.clear()
    def delete_selected(self):
        idx = self.list_widget.currentRow()
        if idx >= 0:
            del self.settings_data["inlay_types"][idx]
            save_settings(self.settings_data)
            self.refresh_list()
    def rename_item(self):
        idx = self.list_widget.currentRow()
        new_name = self.rename_input.text().strip()
        if idx >= 0 and new_name:
            self.settings_data["inlay_types"][idx] = new_name
            save_settings(self.settings_data)
            self.refresh_list()
            self.rename_input.clear()
    def select_item(self, row):
        if row >= 0:
            self.rename_input.setText(self.settings_data["inlay_types"][row])
        else:
            self.rename_input.clear()


class LabelSizeSettingsWidget(QWidget):
    def __init__(self, settings_data):
        super().__init__()
        self.settings_data = settings_data
        layout = QVBoxLayout()
        self.list_widget = QListWidget()
        self.refresh_list()
        layout.addWidget(QLabel("Label Sizes:"))
        layout.addWidget(self.list_widget)
        edit_layout = QHBoxLayout()
        self.new_input = QLineEdit()
        edit_layout.addWidget(self.new_input)
        add_btn = QPushButton("Add")
        add_btn.clicked.connect(self.add_item)
        edit_layout.addWidget(add_btn)
        layout.addLayout(edit_layout)
        edit_rename_layout = QHBoxLayout()
        self.rename_input = QLineEdit()
        edit_rename_layout.addWidget(self.rename_input)
        rename_btn = QPushButton("Rename")
        rename_btn.clicked.connect(self.rename_item)
        edit_rename_layout.addWidget(rename_btn)
        del_btn = QPushButton("Delete")
        del_btn.clicked.connect(self.delete_selected)
        edit_rename_layout.addWidget(del_btn)
        layout.addLayout(edit_rename_layout)
        self.setLayout(layout)
        self.list_widget.currentRowChanged.connect(self.select_item)
    def refresh_list(self):
        self.list_widget.clear()
        self.list_widget.addItems(self.settings_data["label_sizes"])
    def add_item(self):
        name = self.new_input.text().strip()
        if name and name not in self.settings_data["label_sizes"]:
            self.settings_data["label_sizes"].append(name)
            save_settings(self.settings_data)
            self.refresh_list()
            self.new_input.clear()
    def delete_selected(self):
        idx = self.list_widget.currentRow()
        if idx >= 0:
            del self.settings_data["label_sizes"][idx]
            save_settings(self.settings_data)
            self.refresh_list()
    def rename_item(self):
        idx = self.list_widget.currentRow()
        new_name = self.rename_input.text().strip()
        if idx >= 0 and new_name:
            self.settings_data["label_sizes"][idx] = new_name
            save_settings(self.settings_data)
            self.refresh_list()
            self.rename_input.clear()
    def select_item(self, row):
        if row >= 0:
            self.rename_input.setText(self.settings_data["label_sizes"][row])
        else:
            self.rename_input.clear()

class SettingsWidget(QWidget):
    def __init__(self, printer_data):
        super().__init__()
        tabs = QTabWidget()
        # File locations (stub)
        file_tab = QWidget()
        file_layout = QFormLayout()
        file_layout.addRow("CSV File Path:", QLineEdit("Z:\\Path\\to\\csv_data.csv"))
        file_layout.addRow("Template Folder:", QLineEdit("Z:\\Path\\to\\templates"))
        file_tab.setLayout(file_layout)
        tabs.addTab(file_tab, "File Locations")
        # Printer management tab
        printer_tab = PrinterSettingsWidget(printer_data)
        tabs.addTab(printer_tab, "Printers")
        # Inlay & label management
        inlay_tab = InlayTypeSettingsWidget(SETTINGS_DATA)
        labelsize_tab = LabelSizeSettingsWidget(SETTINGS_DATA)
        tabs.addTab(inlay_tab, "Inlay Types")
        tabs.addTab(labelsize_tab, "Label Sizes")
        # User Roles (stub)
        roles_tab = QWidget()
        roles_layout = QVBoxLayout()
        roles_layout.addWidget(QLabel("User Roles (stubbed)"))
        roles_tab.setLayout(roles_layout)
        tabs.addTab(roles_tab, "User Roles")
        theme_btn = QPushButton("Toggle Dark/Light Theme")
        theme_btn.clicked.connect(lambda: QMessageBox.information(self, "Theme", "Theme toggled (mock)."))
        layout = QVBoxLayout()
        layout.addWidget(tabs)
        layout.addWidget(theme_btn)
        self.setLayout(layout)





############################################################
# File: ui\__init__.py
############################################################




############################################################
# File: workflow\bartender_step.py
############################################################
from PyQt6.QtWidgets import *
from data.jobdata import JobData

class BarTenderStep(QWidget):
    def __init__(self, job: JobData):
        super().__init__()
        self.job = job
        layout = QFormLayout()
        self.template_path = QLineEdit()
        browse_template = QPushButton("Browse Template")
        browse_template.clicked.connect(self.browse_template)
        self.dest_path = QLineEdit()
        browse_dest = QPushButton("Browse Dest")
        browse_dest.clicked.connect(self.browse_dest)
        layout.addRow("Template File:", self.template_path)
        layout.addRow("", browse_template)
        layout.addRow("Destination Path:", self.dest_path)
        layout.addRow("", browse_dest)
        link_btn = QPushButton("Link File")
        link_btn.clicked.connect(self.link_file)
        layout.addRow(link_btn)
        self.setLayout(layout)
    def browse_template(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select .btw Template", "", "BarTender Files (*.btw)")
        if path:
            self.template_path.setText(path)
    def browse_dest(self):
        path = QFileDialog.getExistingDirectory(self, "Select Destination")
        if path:
            self.dest_path.setText(path)
    def link_file(self):
        self.job.bartender_file = self.template_path.text()
        QMessageBox.information(self, "Success", "BarTender file linked (mock).")




############################################################
# File: workflow\database_generator.py
############################################################
from PyQt6.QtWidgets import *
import csv
from config import SERIALS_CSV_PATH
from util import update_latest_serial
from data.jobdata import JobData

class DatabaseGeneratorTab(QWidget):
    def __init__(self, job: JobData):
        super().__init__()
        self.job = job
        layout = QVBoxLayout()
        info_lbl = QLabel("Serial numbers in use are listed below.\n"
                          "Enter a new serial or range to check and append if unique.")
        layout.addWidget(info_lbl)
        self.table = QTableWidget()
        self.table.setColumnCount(1)
        self.table.setHorizontalHeaderLabels(['Serial Number'])
        self.table.verticalHeader().setVisible(False)
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        layout.addWidget(self.table)
        self.refresh_table()
        frm = QFormLayout()
        self.serial_input = QLineEdit()
        self.range_input = QLineEdit()
        save_btn = QPushButton("Add Serial(s)")
        save_btn.clicked.connect(self.try_save_serials)
        frm.addRow("Single Serial:", self.serial_input)
        frm.addRow("Or Serial Range (start-end):", self.range_input)
        frm.addRow(save_btn)
        layout.addLayout(frm)
        self.setLayout(layout)
    def refresh_table(self):
        serials = self.get_csv_serials()
        self.table.setRowCount(len(serials))
        for idx, s in enumerate(serials):
            item = QTableWidgetItem(s)
            self.table.setItem(idx, 0, item)
    @staticmethod
    def get_csv_serials():
        # Returns list of strings, skipping the header
        try:
            with open(SERIALS_CSV_PATH, newline='') as f:
                reader = csv.reader(f)
                next(reader, None)  # header
                return [x[0] for x in reader]
        except Exception:
            return []
    def try_save_serials(self):
        current_serials = set(self.get_csv_serials())
        added = []
        # Single
        val = self.serial_input.text().strip()
        if val:
            if val in current_serials:
                QMessageBox.warning(self, "Duplicate", f"Serial {val} already exists.")
                return
            added.append(val)
        # Range
        range_val = self.range_input.text().strip()
        if range_val:
            try:
                start, end = [x.strip() for x in range_val.split('-')]
                start, end = int(start), int(end)
                candidate = [str(s) for s in range(start, end+1)]
                duplicates = [s for s in candidate if s in current_serials]
                if duplicates:
                    QMessageBox.warning(self, "Duplicate", f"These serials already exist: {', '.join(duplicates)}")
                    return
                added.extend(candidate)
            except Exception:
                QMessageBox.warning(self, "Error", "Serial range format must be start-end (e.g. 1000-1010)")
                return
        if not added:
            QMessageBox.information(self, "None", "Nothing to add.")
            return
        # Append
        with open(SERIALS_CSV_PATH, 'a', newline='') as f:
            writer = csv.writer(f)
            for s in added:
                writer.writerow([s])
        if added:           
            last_serial = int(added[-1])  # serials were str but numeric
            update_latest_serial(last_serial + 1)        
        self.refresh_table()
        QMessageBox.information(self, "Saved", f"Saved {len(added)} serials. They are now reserved.")
        




############################################################
# File: workflow\docs_export.py
############################################################
from PyQt6.QtWidgets import *
from data.jobdata import JobData

class DocsExportStep(QWidget):
    def __init__(self, job: JobData):
        super().__init__()
        self.job = job
        layout = QVBoxLayout()
        layout.addWidget(QLabel("Export Docs/Archive Job"))
        pdf_btn = QPushButton("Export as PDF")
        pdf_btn.clicked.connect(lambda: QMessageBox.information(self, "PDF", "Job docs exported (mock)"))
        finish_btn = QPushButton("Mark Complete")
        finish_btn.clicked.connect(self.finish_job)
        layout.addWidget(pdf_btn)
        layout.addWidget(finish_btn)
        self.setLayout(layout)
    def finish_job(self):
        self.job.status = "Complete"
        QMessageBox.information(self, "Done", "Job marked complete (mock).")




############################################################
# File: workflow\encoding_checklist.py
############################################################
#Encoding_checklist.py
from PyQt6.QtWidgets import *
from PyQt6.QtGui import QIntValidator, QRegularExpressionValidator
from PyQt6.QtWidgets import QCompleter
from PyQt6.QtCore import Qt, QDate, QStringListModel, QRegularExpression

from data.jobdata import JobData
from data.serial_tracker import reserve_serials

from data.job_folder import create_job_folders
from util import load_settings

from PyQt6.QtPdfWidgets import QPdfView
from PyQt6.QtPdf import QPdfDocument


from pypdf import PdfReader, PdfWriter

import os
SETTINGS_DATA = load_settings()

class EncodingChecklistTab(QWidget):
    # --- PDF template assumed at project root (template.pdf) ---
    PDF_TEMPLATE = r"Z:\3 Encoding and Printing Files\Checklists & Spreadsheets\Encoding Checklist V4.1.pdf"

    def __init__(self, job, jobs_modwidget=None):
        super().__init__()
        self.job = job
        self.jobs_modwidget = jobs_modwidget   # to call back for 'edit'
        self.layout = QVBoxLayout()
        self._pdf_path = self._get_pdf_outpath()
        self.pdf_widget = QPdfView(self)
        self.btn_edit = QPushButton("Edit Checklist")
        self.btn_edit.clicked.connect(self._edit)

        self.layout.addWidget(self.pdf_widget)
        hlayout = QHBoxLayout()
        hlayout.addStretch()
        hlayout.addWidget(self.btn_edit)
        self.layout.addLayout(hlayout)
        self.setLayout(self.layout)

        if not os.path.exists(self._pdf_path):
            # No checklist yet, so create it
            self._fill_and_save_pdf()

        self._load_pdf_viewer()

    def _edit(self):
        # Re-open wizard (prefilled), update, refill pdf, reload view
        if self.jobs_modwidget: # Use outer widget's dialog for consistency
            self.jobs_modwidget.new_job_dialog(prefill=self.job.checklist_data)
            # Here, after dialog the self.job.checklist_data may be updated
            self._fill_and_save_pdf()
            self._load_pdf_viewer()

    def _get_pdf_outpath(self):
        # Checklist PDF lives in job's Checklist subfolder
        checklist_dir = os.path.join(self.job.folder_path, 'Checklist')
        os.makedirs(checklist_dir, exist_ok=True)
        return os.path.join(checklist_dir, "checklist.pdf")

    def _fill_and_save_pdf(self):
        import subprocess
        from pypdf import PdfReader, PdfWriter
        from pypdf.generic import NameObject

        src = self.PDF_TEMPLATE
        dst = self._pdf_path
        reader = PdfReader(src)
        writer = PdfWriter()
        field_values = self.job.checklist_data.copy()

        # Print for debug: You can comment this out
        print("Checklist fields to fill:")
        for k in reader.get_fields():
            print(f"{k}: {field_values.get(k, '')}")

        fields = {k: str(field_values.get(k,'')) for k in reader.get_fields()}

        writer.append_pages_from_reader(reader)
        if "/AcroForm" in reader.trailer["/Root"]:
            writer._root_object.update({
                NameObject("/AcroForm"): reader.trailer["/Root"]["/AcroForm"]
            })
        else:
            raise RuntimeError("Template is missing /AcroForm! Cannot fill form.")
        writer.update_page_form_field_values(writer.pages[0], fields)
        with open(dst, "wb") as outf:
            writer.write(outf)

        # Try qpdf flattening first, then pdftk, else fallback
        flattened = dst.replace(".pdf", "_flat.pdf")
        flattened_success = False
        flatten_tool_used = ""

        # Try qpdf flattening (preferred, more modern)
        try:
            result = subprocess.run(["qpdf", "--flatten-annotations=all", dst, flattened], check=True)
            os.replace(flattened, dst)
            flattened_success = True
            flatten_tool_used = "qpdf"
        except FileNotFoundError:
            pass  # qpdf not available, will try pdftk
        except Exception as ex:
            print("qpdf flatten failed:", ex)

        # Try pdftk as fallback
        if not flattened_success:
            try:
                result = subprocess.run(
                    ["pdftk", dst, "output", flattened, "flatten"], check=True
                )
                os.replace(flattened, dst)
                flattened_success = True
                flatten_tool_used = "pdftk"
            except FileNotFoundError:
                pass  # pdftk not available
            except Exception as ex:
                print("pdftk flatten failed:", ex)

        # FINAL check
        if not flattened_success:
            QMessageBox.warning(self, "PDF Flattening Disabled",
                "WARNING: Neither qpdf nor pdftk found. The checklist PDF will NOT be properly flattened, "
                "and may appear blank in this app.\n\n"
                "To fix: install qpdf (https://sourceforge.net/projects/qpdf/) or pdftk (https://www.pdflabs.com/tools/pdftk-server/) "
                "and add it to your PATH, then restart this program.")
        else:
            print(f"Checklist successfully flattened with {flatten_tool_used}.")


    def _load_pdf_viewer(self):
        import time
        time.sleep(0.1)  # thoroughly ensure flush; remove for SSDs if fast enough
        doc = QPdfDocument(self)
        status = doc.load(self._pdf_path)
        if status != QPdfDocument.Status.Ready:
            QMessageBox.warning(self, "PDF error", f"Failed to load checklist PDF at {self._pdf_path}")
        self.pdf_widget.setDocument(None)
        self.pdf_widget.setDocument(doc)




############################################################
# File: workflow\roll_tracker.py
############################################################
from PyQt6.QtWidgets import *
from data.jobdata import JobData


class RollTrackerStep(QWidget):
    def __init__(self, job: JobData, segments=3):
        super().__init__()
        layout = QVBoxLayout()
        qty = job.qty
        segment_size = qty // segments if segments else qty
        layout.addWidget(QLabel(f"Total: {qty} | Rolls: {segments}"))
        for roll in range(1, segments+1):
            bar = QProgressBar()
            val = (segment_size / qty * 100) if roll < segments else (
                ((qty - (segments-1)*segment_size)/qty)*100)
            bar.setValue(int(val))
            bar.setFormat(f"Roll {roll}: {segment_size} labels")
            layout.addWidget(bar)
        export_btn = QPushButton("Export Roll Tracker")
        export_btn.clicked.connect(lambda: QMessageBox.information(self, "PDF", "Exported roll tracker (mock)"))
        layout.addWidget(export_btn)
        self.setLayout(layout)



############################################################
# File: workflow\test_print.py
############################################################
from PyQt6.QtWidgets import *
from data.jobdata import JobData
import random

class TestPrintStep(QWidget):
    def __init__(self, job: JobData):
        super().__init__()
        layout = QVBoxLayout()
        layout.addWidget(QLabel("Test Print & Signoff"))
        print_btn = QPushButton("Print 5")
        print_btn.clicked.connect(self.print_labels)
        layout.addWidget(print_btn)
        self.result_list = QListWidget()
        layout.addWidget(self.result_list)
        sign_btn = QPushButton("Digital Signoff")
        sign_btn.clicked.connect(self.sign_off)
        layout.addWidget(sign_btn)
        self.setLayout(layout)
    def print_labels(self):
        self.result_list.clear()
        for i in range(5):
            self.result_list.addItem(f"Label {i+1}: EPC {random.randint(10000,99999)} - PASS")
        QMessageBox.information
        QMessageBox.information(self, "Printed", "Test print (mock)")
    def sign_off(self):
        QMessageBox.information(self, "Signoff", "Test print signed off (mock)")




############################################################
# File: workflow\__init__.py
############################################################




