# === File: jobs_module.py ===
from PyQt6.QtWidgets import *
from jobdata import JobData
from encoding_checklist import EncodingChecklistTab
from database_generator import DatabaseGeneratorTab
from roll_tracker import RollTrackerStep
from bartender_step import BarTenderStep
from test_print import TestPrintStep
from docs_export import DocsExportStep
from PyQt6.QtGui import QIntValidator
from module_selector import ModuleSelectionDialog


class SingleJobWorkflowWidget(QWidget):
    def __init__(self, job: JobData):
        super().__init__()
        layout = QVBoxLayout()
        tabs = QTabWidget()
        # --- Tabs renamed and new content ---
        
        tabs.addTab(EncodingChecklistTab(job), "Encoding Checklist")
        tabs.addTab(DatabaseGeneratorTab(job), "Database Generator")
        tabs.addTab(RollTrackerStep(job), "Roll Tracker")
        tabs.addTab(BarTenderStep(job), "BarTender")
        tabs.addTab(TestPrintStep(job), "Test Print & QC")
        tabs.addTab(DocsExportStep(job), "Docs/Export")
        layout.addWidget(tabs)
        self.setLayout(layout)

class JobsModuleWidget(QWidget):
    def __init__(self):
        super().__init__()
        split = QSplitter()
        self.job_list = QListWidget()
        self.new_btn = QPushButton("New Job")
        self.new_btn.setMaximumWidth(150)
        left_layout = QVBoxLayout()
        left_layout.addWidget(QLabel("All Jobs"))
        left_layout.addWidget(self.job_list)
        left_layout.addWidget(self.new_btn)
        left_panel = QWidget()
        left_panel.setLayout(left_layout)
        self.right_panel = QWidget()
        self.right_panel_layout = QVBoxLayout()
        self.right_panel_layout.addWidget(QLabel("No job selected."))
        self.right_panel.setLayout(self.right_panel_layout)
        split.addWidget(left_panel)
        split.addWidget(self.right_panel)
        split.setStretchFactor(1, 2)
        layout = QHBoxLayout()
        layout.addWidget(split)
        self.setLayout(layout)
        self.jobs = []
        # DEMO jobs
        for i in range(2):
            job = JobData(f"DemoJob_{i+1}", f"UPC00{i+1}", (i+1)*1000)
            self.jobs.append(job)
            self.job_list.addItem(job.name)
        self.job_list.currentRowChanged.connect(self.select_job)
        self.new_btn.clicked.connect(self.new_job_dialog)
    def select_job(self, row):
        if row >= 0 and row < len(self.jobs):
            job = self.jobs[row]
            while self.right_panel_layout.count():
                item = self.right_panel_layout.takeAt(0)
                widget = item.widget()
                if widget: widget.deleteLater()
            self.right_panel_layout.addWidget(SingleJobWorkflowWidget(job))
        else:
            while self.right_panel_layout.count():
                item = self.right_panel_layout.takeAt(0)
                widget = item.widget()
                if widget: widget.deleteLater()
            self.right_panel_layout.addWidget(QLabel("No job selected."))
    def new_job_dialog(self):
        dlg = QDialog(self)
        dlg.setWindowTitle("New Job")
        form = QFormLayout(dlg)
        jobname = QLineEdit()
        code = QLineEdit()
        qty = QLineEdit()
        qty.setValidator(QIntValidator(1, 999999999))
        form.addRow("Job Name:", jobname)
        form.addRow("Product Code:", code)
        form.addRow("Qty:", qty)
        okbtn = QPushButton("Next")
        cancelbtn = QPushButton("Cancel")
        btns = QHBoxLayout()
        btns.addWidget(okbtn)
        btns.addWidget(cancelbtn)
        form.addRow(btns)
        def on_next():
            if not jobname.text() or not code.text() or not qty.text().isdigit():
                QMessageBox.warning(dlg, "Error", "Fill all fields, qty must be number.")
                return
            # Go to module selection
            mod_sel_dlg = ModuleSelectionDialog(dlg)
            if mod_sel_dlg.exec() == QDialog.DialogCode.Accepted:
                modules = mod_sel_dlg.get_selection()
                if not any(modules.values()):
                    QMessageBox.warning(dlg, "Error", "You must select at least one module.")
                    return
                # Create job and store modules config
                job = JobData(jobname.text(), code.text(), int(qty.text()), modules=modules)
                self.jobs.append(job)
                self.job_list.addItem(job.name)
                dlg.accept()
            # else: stay on current dialog for more input/abort
        okbtn.clicked.connect(on_next)
        cancelbtn.clicked.connect(dlg.reject)
        dlg.exec()
        def on_create():
            if not jobname.text() or not code.text() or not qty.text().isdigit():
                QMessageBox.warning(dlg, "Error", "Fill all fields, qty must be number.")
                return
            job = JobData(jobname.text(), code.text(), int(qty.text()))
            self.jobs.append(job)
            self.job_list.addItem(job.name)
            dlg.accept()
        okbtn.clicked.connect(on_create)
        cancelbtn.clicked.connect(dlg.reject)
        dlg.exec()


# === File: main.py ===
import sys
import random
from PyQt6.QtWidgets import QApplication, QMainWindow, QTabWidget
from dashboard import DashboardWidget
from jobs_module import JobsModuleWidget
from reports import ReportsWidget
from settings import SettingsWidget
from util import current_time_str

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("RFID Workflow Management Suite")
        self.resize(1200, 800)
        # Printer data (mock, globally shared)
        self.printer_data = {}
        for i in range(1, 11):
            pid = f"p{str(i).zfill(2)}"
            base_pass = 10 * random.randint(1, 5)
            self.printer_data[pid] = {
                "printer_id": pid,
                "pass_count": base_pass,
                "fail_count": random.randint(0, base_pass // 2),
                "last_event": current_time_str()
            }
        tabs = QTabWidget()
        tabs.addTab(DashboardWidget(self.printer_data), "Dashboard")
        tabs.addTab(JobsModuleWidget(), "Jobs")
        tabs.addTab(ReportsWidget(), "Reports")
        tabs.addTab(SettingsWidget(self.printer_data), "Settings")
        self.setCentralWidget(tabs)

def main():
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())

if __name__ == '__main__':
    main()

# === File: module_selector.py ===
# module_selector.py

from PyQt6.QtWidgets import QDialog, QVBoxLayout, QCheckBox, QPushButton, QHBoxLayout, QLabel

class ModuleSelectionDialog(QDialog):
    """
    Dialog asking which workflow modules to use for a new job.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Select Workflow Modules")
        layout = QVBoxLayout()
        msg = QLabel(
            "Choose which modules to use for this job.\n"
            "You can choose any combination, but at least one."
        )
        layout.addWidget(msg)
        self.cb_checklist = QCheckBox("Encoding Checklist")
        self.cb_dbgen = QCheckBox("Database Generator")
        self.cb_rolltracker = QCheckBox("Roll Tracker")
        self.cb_checklist.setChecked(True)
        self.cb_dbgen.setChecked(False)
        self.cb_rolltracker.setChecked(False)
        layout.addWidget(self.cb_checklist)
        layout.addWidget(self.cb_dbgen)
        layout.addWidget(self.cb_rolltracker)
        btn_layout = QHBoxLayout()
        ok_btn = QPushButton("Start Workflow")
        cancel_btn = QPushButton("Cancel")
        btn_layout.addWidget(ok_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        ok_btn.clicked.connect(self.accept)
        cancel_btn.clicked.connect(self.reject)

    def get_selection(self):
        return {
            "show_checklist": self.cb_checklist.isChecked(),
            "show_dbgen": self.cb_dbgen.isChecked(),
            "show_rolltracker": self.cb_rolltracker.isChecked()
        }

# === File: reports.py ===
from PyQt6.QtWidgets import *

class ReportsWidget(QWidget):
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout()
        filter_layout = QHBoxLayout()
        filter_layout.addWidget(QLabel("Filter by Job/Date:"))
        self.filter_input = QLineEdit()
        filter_layout.addWidget(self.filter_input)
        layout.addLayout(filter_layout)
        csv_btn = QPushButton("Download CSV")
        csv_btn.clicked.connect(lambda: QMessageBox.information(self, "Download", "CSV downloaded (mock)."))
        pdf_btn = QPushButton("Download PDF")
        pdf_btn.clicked.connect(lambda: QMessageBox.information(self, "Download", "PDF downloaded (mock)."))
        layout.addWidget(csv_btn)
        layout.addWidget(pdf_btn)
        self.setLayout(layout)

# === File: roll_tracker.py ===
from PyQt6.QtWidgets import *
from jobdata import JobData

class RollTrackerStep(QWidget):
    def __init__(self, job: JobData, segments=3):
        super().__init__()
        layout = QVBoxLayout()
        qty = job.qty
        segment_size = qty // segments if segments else qty
        layout.addWidget(QLabel(f"Total: {qty} | Rolls: {segments}"))
        for roll in range(1, segments+1):
            bar = QProgressBar()
            val = (segment_size / qty * 100) if roll < segments else (
                ((qty - (segments-1)*segment_size)/qty)*100)
            bar.setValue(int(val))
            bar.setFormat(f"Roll {roll}: {segment_size} labels")
            layout.addWidget(bar)
        export_btn = QPushButton("Export Roll Tracker")
        export_btn.clicked.connect(lambda: QMessageBox.information(self, "PDF", "Exported roll tracker (mock)"))
        layout.addWidget(export_btn)
        self.setLayout(layout)

# === File: settings.py ===
from PyQt6.QtWidgets import *
from PyQt6.QtCore import Qt
from util import load_settings, save_settings, current_time_str
SETTINGS_DATA = load_settings()

class PrinterSettingsWidget(QWidget):
    def __init__(self, printer_data):
        super().__init__()
        self.printer_data = printer_data
        layout = QVBoxLayout()
        self.table = QTableWidget()
        self.table.setColumnCount(1)
        self.table.setHorizontalHeaderLabels(["Printer Name"])
        self.table.verticalHeader().setVisible(False)
        self.table.setEditTriggers(QTableWidget.EditTrigger.DoubleClicked |
                                    QTableWidget.EditTrigger.SelectedClicked)
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        layout.addWidget(self.table)
        add_layout = QHBoxLayout()
        self.new_printer_edit = QLineEdit()
        self.new_printer_edit.setPlaceholderText("New printer name")
        add_layout.addWidget(self.new_printer_edit)
        add_btn = QPushButton("Add Printer")
        add_btn.clicked.connect(self.add_printer)
        add_layout.addWidget(add_btn)
        layout.addLayout(add_layout)
        del_btn = QPushButton("Delete Selected")
        del_btn.clicked.connect(self.delete_selected)
        layout.addWidget(del_btn)
        save_btn = QPushButton("Save Changes")
        save_btn.clicked.connect(self.save_changes)
        layout.addWidget(save_btn)
        self.setLayout(layout)
        self.populate_table()
    def populate_table(self):
        printers = sorted(self.printer_data.keys())
        self.table.setRowCount(len(printers))
        for idx, pid in enumerate(printers):
            item = QTableWidgetItem(pid)
            item.setFlags(item.flags() | Qt.ItemFlag.ItemIsEditable)
            self.table.setItem(idx, 0, item)
    def add_printer(self):
        name = self.new_printer_edit.text().strip()
        if name:
            if name in self.printer_data:
                QMessageBox.warning(self, "Duplicate", "Printer already exists.")
            else:
                self.printer_data[name] = {"printer_id": name,
                                           "pass_count": 0,
                                           "fail_count": 0,
                                           "last_event": current_time_str()}
                self.populate_table()
                self.new_printer_edit.clear()
    def delete_selected(self):
        selected = self.table.selectedItems()
        if selected:
            for item in selected:
                pid = item.text()
                if pid in self.printer_data:
                    del self.printer_data[pid]
            self.populate_table()
    def save_changes(self):
        new_data = {}
        for row in range(self.table.rowCount()):
            item = self.table.item(row, 0)
            if item:
                new_name = item.text().strip()
                if new_name:
                    if new_name in self.printer_data:
                        new_data[new_name] = self.printer_data[new_name]
                    else:
                        new_data[new_name] = {"printer_id": new_name,
                                              "pass_count": 0,
                                              "fail_count": 0,
                                              "last_event": current_time_str()}
        self.printer_data.clear()
        self.printer_data.update(new_data)
        QMessageBox.information(self, "Saved", "Printer settings updated.")

class InlayTypeSettingsWidget(QWidget):
    def __init__(self, settings_data):
        super().__init__()
        self.settings_data = settings_data
        layout = QVBoxLayout()
        self.list_widget = QListWidget()
        self.refresh_list()
        layout.addWidget(QLabel("Inlay Types:"))
        layout.addWidget(self.list_widget)
        edit_layout = QHBoxLayout()
        self.new_input = QLineEdit()
        edit_layout.addWidget(self.new_input)
        add_btn = QPushButton("Add")
        add_btn.clicked.connect(self.add_item)
        edit_layout.addWidget(add_btn)
        layout.addLayout(edit_layout)
        edit_rename_layout = QHBoxLayout()
        self.rename_input = QLineEdit()
        edit_rename_layout.addWidget(self.rename_input)
        rename_btn = QPushButton("Rename")
        rename_btn.clicked.connect(self.rename_item)
        edit_rename_layout.addWidget(rename_btn)
        del_btn = QPushButton("Delete")
        del_btn.clicked.connect(self.delete_selected)
        edit_rename_layout.addWidget(del_btn)
        layout.addLayout(edit_rename_layout)
        self.setLayout(layout)
        self.list_widget.currentRowChanged.connect(self.select_item)
    def refresh_list(self):
        self.list_widget.clear()
        self.list_widget.addItems(self.settings_data["inlay_types"])
    def add_item(self):
        name = self.new_input.text().strip()
        if name and name not in self.settings_data["inlay_types"]:
            self.settings_data["inlay_types"].append(name)
            save_settings(self.settings_data)
            self.refresh_list()
            self.new_input.clear()
    def delete_selected(self):
        idx = self.list_widget.currentRow()
        if idx >= 0:
            del self.settings_data["inlay_types"][idx]
            save_settings(self.settings_data)
            self.refresh_list()
    def rename_item(self):
        idx = self.list_widget.currentRow()
        new_name = self.rename_input.text().strip()
        if idx >= 0 and new_name:
            self.settings_data["inlay_types"][idx] = new_name
            save_settings(self.settings_data)
            self.refresh_list()
            self.rename_input.clear()
    def select_item(self, row):
        if row >= 0:
            self.rename_input.setText(self.settings_data["inlay_types"][row])
        else:
            self.rename_input.clear()


class LabelSizeSettingsWidget(QWidget):
    def __init__(self, settings_data):
        super().__init__()
        self.settings_data = settings_data
        layout = QVBoxLayout()
        self.list_widget = QListWidget()
        self.refresh_list()
        layout.addWidget(QLabel("Label Sizes:"))
        layout.addWidget(self.list_widget)
        edit_layout = QHBoxLayout()
        self.new_input = QLineEdit()
        edit_layout.addWidget(self.new_input)
        add_btn = QPushButton("Add")
        add_btn.clicked.connect(self.add_item)
        edit_layout.addWidget(add_btn)
        layout.addLayout(edit_layout)
        edit_rename_layout = QHBoxLayout()
        self.rename_input = QLineEdit()
        edit_rename_layout.addWidget(self.rename_input)
        rename_btn = QPushButton("Rename")
        rename_btn.clicked.connect(self.rename_item)
        edit_rename_layout.addWidget(rename_btn)
        del_btn = QPushButton("Delete")
        del_btn.clicked.connect(self.delete_selected)
        edit_rename_layout.addWidget(del_btn)
        layout.addLayout(edit_rename_layout)
        self.setLayout(layout)
        self.list_widget.currentRowChanged.connect(self.select_item)
    def refresh_list(self):
        self.list_widget.clear()
        self.list_widget.addItems(self.settings_data["label_sizes"])
    def add_item(self):
        name = self.new_input.text().strip()
        if name and name not in self.settings_data["label_sizes"]:
            self.settings_data["label_sizes"].append(name)
            save_settings(self.settings_data)
            self.refresh_list()
            self.new_input.clear()
    def delete_selected(self):
        idx = self.list_widget.currentRow()
        if idx >= 0:
            del self.settings_data["label_sizes"][idx]
            save_settings(self.settings_data)
            self.refresh_list()
    def rename_item(self):
        idx = self.list_widget.currentRow()
        new_name = self.rename_input.text().strip()
        if idx >= 0 and new_name:
            self.settings_data["label_sizes"][idx] = new_name
            save_settings(self.settings_data)
            self.refresh_list()
            self.rename_input.clear()
    def select_item(self, row):
        if row >= 0:
            self.rename_input.setText(self.settings_data["label_sizes"][row])
        else:
            self.rename_input.clear()

class SettingsWidget(QWidget):
    def __init__(self, printer_data):
        super().__init__()
        tabs = QTabWidget()
        # File locations (stub)
        file_tab = QWidget()
        file_layout = QFormLayout()
        file_layout.addRow("CSV File Path:", QLineEdit("Z:\\Path\\to\\csv_data.csv"))
        file_layout.addRow("Template Folder:", QLineEdit("Z:\\Path\\to\\templates"))
        file_tab.setLayout(file_layout)
        tabs.addTab(file_tab, "File Locations")
        # Printer management tab
        printer_tab = PrinterSettingsWidget(printer_data)
        tabs.addTab(printer_tab, "Printers")
        # Inlay & label management
        inlay_tab = InlayTypeSettingsWidget(SETTINGS_DATA)
        labelsize_tab = LabelSizeSettingsWidget(SETTINGS_DATA)
        tabs.addTab(inlay_tab, "Inlay Types")
        tabs.addTab(labelsize_tab, "Label Sizes")
        # User Roles (stub)
        roles_tab = QWidget()
        roles_layout = QVBoxLayout()
        roles_layout.addWidget(QLabel("User Roles (stubbed)"))
        roles_tab.setLayout(roles_layout)
        tabs.addTab(roles_tab, "User Roles")
        theme_btn = QPushButton("Toggle Dark/Light Theme")
        theme_btn.clicked.connect(lambda: QMessageBox.information(self, "Theme", "Theme toggled (mock)."))
        layout = QVBoxLayout()
        layout.addWidget(tabs)
        layout.addWidget(theme_btn)
        self.setLayout(layout)



# === File: test_print.py ===
from PyQt6.QtWidgets import *
from jobdata import JobData
import random

class TestPrintStep(QWidget):
    def __init__(self, job: JobData):
        super().__init__()
        layout = QVBoxLayout()
        layout.addWidget(QLabel("Test Print & Signoff"))
        print_btn = QPushButton("Print 5")
        print_btn.clicked.connect(self.print_labels)
        layout.addWidget(print_btn)
        self.result_list = QListWidget()
        layout.addWidget(self.result_list)
        sign_btn = QPushButton("Digital Signoff")
        sign_btn.clicked.connect(self.sign_off)
        layout.addWidget(sign_btn)
        self.setLayout(layout)
    def print_labels(self):
        self.result_list.clear()
        for i in range(5):
            self.result_list.addItem(f"Label {i+1}: EPC {random.randint(10000,99999)} - PASS")
        QMessageBox.information
        QMessageBox.information(self, "Printed", "Test print (mock)")
    def sign_off(self):
        QMessageBox.information(self, "Signoff", "Test print signed off (mock)")


# === File: util.py ===
import os
import csv
import datetime
from config import SERIALS_CSV_PATH, SETTINGS_JSON, DEFAULT_SETTINGS
import json

def current_time_str():
    return datetime.datetime.now().strftime("%H:%M:%S")

def load_settings():
    if not os.path.exists(SETTINGS_JSON):
        with open(SETTINGS_JSON, "w") as f:
            json.dump(DEFAULT_SETTINGS, f, indent=2)
        return DEFAULT_SETTINGS.copy()
    with open(SETTINGS_JSON, "r") as f:
        return json.load(f)

def save_settings(data):
    with open(SETTINGS_JSON, "w") as f:
        json.dump(data, f, indent=2)

def get_latest_serial():
    try:
        with open(SERIALS_CSV_PATH, "r", newline="") as f:
            reader = csv.reader(f)
            next(reader, None)
            row = next(reader, None)
            return int(row[0]) if row and row[0].isdigit() else 1
    except Exception:
        os.makedirs(os.path.dirname(SERIALS_CSV_PATH), exist_ok=True)
        with open(SERIALS_CSV_PATH, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(['latest_serial'])
            writer.writerow(['1'])
        return 1

def update_latest_serial(new_serial):
    with open(SERIALS_CSV_PATH, "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["latest_serial"])
        writer.writerow([str(new_serial)])

# === File: bartender_step.py ===
from PyQt6.QtWidgets import *
from jobdata import JobData

class BarTenderStep(QWidget):
    def __init__(self, job: JobData):
        super().__init__()
        self.job = job
        layout = QFormLayout()
        self.template_path = QLineEdit()
        browse_template = QPushButton("Browse Template")
        browse_template.clicked.connect(self.browse_template)
        self.dest_path = QLineEdit()
        browse_dest = QPushButton("Browse Dest")
        browse_dest.clicked.connect(self.browse_dest)
        layout.addRow("Template File:", self.template_path)
        layout.addRow("", browse_template)
        layout.addRow("Destination Path:", self.dest_path)
        layout.addRow("", browse_dest)
        link_btn = QPushButton("Link File")
        link_btn.clicked.connect(self.link_file)
        layout.addRow(link_btn)
        self.setLayout(layout)
    def browse_template(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select .btw Template", "", "BarTender Files (*.btw)")
        if path:
            self.template_path.setText(path)
    def browse_dest(self):
        path = QFileDialog.getExistingDirectory(self, "Select Destination")
        if path:
            self.dest_path.setText(path)
    def link_file(self):
        self.job.bartender_file = self.template_path.text()
        QMessageBox.information(self, "Success", "BarTender file linked (mock).")


# === File: config.py ===
import os
import json

SERIALS_CSV_PATH = r"Z:\3 Encoding and Printing Files\SERIALS_CSV_PATH.csv"
SETTINGS_JSON = r"settings_config.json"
DEFAULT_SETTINGS = {
    "inlay_types": ["Tageos EOS-300", "Avery AD-237", "Impinj MR6-P"],
    "label_sizes": ["2 x 1", "3 x 1", "4 x 2"]
}

# === File: dashboard.py ===
from PyQt6.QtWidgets import *
from PyQt6.QtGui import QFont
from PyQt6.QtCore import QTimer, Qt
from util import current_time_str
import random

# ---------- Dashboard ----------
class PrinterDetailDialog(QDialog):
    def __init__(self, printer_data):
        super().__init__()
        self.setWindowTitle(f"Details for {printer_data['printer_id']}")
        self.resize(400, 300)
        layout = QVBoxLayout()
        layout.addWidget(QLabel(f"Printer Name: {printer_data['printer_id']}"))
        printed = printer_data["pass_count"] + printer_data["fail_count"]
        layout.addWidget(QLabel(f"Total Printed: {printed}"))
        layout.addWidget(QLabel(f"Total Voided: {printer_data['fail_count']}"))
        error_pct = f"{(printer_data['fail_count']/printed * 100):.1f}%" if printed > 0 else "0%"
        layout.addWidget(QLabel(f"Quality Error %: {error_pct}"))
        layout.addWidget(QLabel(f"Last Update: {printer_data['last_event']}"))
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        layout.addWidget(close_btn)
        self.setLayout(layout)

class DashboardWidget(QWidget):
    def __init__(self, printer_data):
        super().__init__()
        self.all_printers = printer_data
        main_layout = QVBoxLayout()
        header_layout = QHBoxLayout()
        header_label = QLabel("Dashboard / Live Monitor")
        header_label.setStyleSheet("font-size: 16px; font-weight: bold;")
        header_layout.addWidget(header_label)
        header_layout.addStretch()
        self.interval_selector = QComboBox()
        self.interval_selector.addItems(["Live", "1 hour", "4 hours", "8 hours"])
        header_layout.addWidget(QLabel("Interval:"))
        header_layout.addWidget(self.interval_selector)
        main_layout.addLayout(header_layout)
        self.table = QTableWidget()
        self.table.setColumnCount(4)
        self.table.setHorizontalHeaderLabels(["Printer", "Printed", "Voided", "Error %"])
        self.table.verticalHeader().setVisible(False)
        self.table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        font = QFont()
        font.setPointSize(11)
        self.table.setFont(font)
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.table.verticalHeader().setDefaultSectionSize(30)
        self.table.cellDoubleClicked.connect(self.handle_row_click)
        main_layout.addWidget(self.table)
        self.setLayout(main_layout)
        self.populate_table()
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_table_data)
        self.timer.start(3000)
    def populate_table(self):
        printers = sorted(self.all_printers.keys())
        self.table.setRowCount(len(printers))
        for idx, pid in enumerate(printers):
            data = self.all_printers[pid]
            printed = data["pass_count"] + data["fail_count"]
            voided = data["fail_count"]
            error_pct = f"{(voided/printed * 100):.1f}%" if printed > 0 else "0%"
            self.table.setItem(idx, 0, QTableWidgetItem(pid))
            self.table.setItem(idx, 1, QTableWidgetItem(str(printed)))
            self.table.setItem(idx, 2, QTableWidgetItem(str(voided)))
            self.table.setItem(idx, 3, QTableWidgetItem(error_pct))
    def update_table_data(self):
        interval = self.interval_selector.currentText()
        multiplier = {"Live": 1, "1 hour": 1, "4 hours": 2, "8 hours": 3}.get(interval, 1)
        for pid in self.all_printers:
            data = self.all_printers[pid]
            data["pass_count"] += random.randint(0, 5 * multiplier)
            data["fail_count"] += random.randint(0, 3 * multiplier)
            data["last_event"] = current_time_str()
        self.populate_table()
    def handle_row_click(self, row, column):
        pid_item = self.table.item(row, 0)
        if pid_item:
            pid = pid_item.text()
            printer_data = self.all_printers.get(pid)
            if printer_data:
                dlg = PrinterDetailDialog(printer_data)
                dlg.exec()

# === File: database_generator.py ===
from PyQt6.QtWidgets import *
import csv
from config import SERIALS_CSV_PATH
from util import update_latest_serial
from jobdata import JobData

class DatabaseGeneratorTab(QWidget):
    def __init__(self, job: JobData):
        super().__init__()
        self.job = job
        layout = QVBoxLayout()
        info_lbl = QLabel("Serial numbers in use are listed below.\n"
                          "Enter a new serial or range to check and append if unique.")
        layout.addWidget(info_lbl)
        self.table = QTableWidget()
        self.table.setColumnCount(1)
        self.table.setHorizontalHeaderLabels(['Serial Number'])
        self.table.verticalHeader().setVisible(False)
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        layout.addWidget(self.table)
        self.refresh_table()
        frm = QFormLayout()
        self.serial_input = QLineEdit()
        self.range_input = QLineEdit()
        save_btn = QPushButton("Add Serial(s)")
        save_btn.clicked.connect(self.try_save_serials)
        frm.addRow("Single Serial:", self.serial_input)
        frm.addRow("Or Serial Range (start-end):", self.range_input)
        frm.addRow(save_btn)
        layout.addLayout(frm)
        self.setLayout(layout)
    def refresh_table(self):
        serials = self.get_csv_serials()
        self.table.setRowCount(len(serials))
        for idx, s in enumerate(serials):
            item = QTableWidgetItem(s)
            self.table.setItem(idx, 0, item)
    @staticmethod
    def get_csv_serials():
        # Returns list of strings, skipping the header
        try:
            with open(SERIALS_CSV_PATH, newline='') as f:
                reader = csv.reader(f)
                next(reader, None)  # header
                return [x[0] for x in reader]
        except Exception:
            return []
    def try_save_serials(self):
        current_serials = set(self.get_csv_serials())
        added = []
        # Single
        val = self.serial_input.text().strip()
        if val:
            if val in current_serials:
                QMessageBox.warning(self, "Duplicate", f"Serial {val} already exists.")
                return
            added.append(val)
        # Range
        range_val = self.range_input.text().strip()
        if range_val:
            try:
                start, end = [x.strip() for x in range_val.split('-')]
                start, end = int(start), int(end)
                candidate = [str(s) for s in range(start, end+1)]
                duplicates = [s for s in candidate if s in current_serials]
                if duplicates:
                    QMessageBox.warning(self, "Duplicate", f"These serials already exist: {', '.join(duplicates)}")
                    return
                added.extend(candidate)
            except Exception:
                QMessageBox.warning(self, "Error", "Serial range format must be start-end (e.g. 1000-1010)")
                return
        if not added:
            QMessageBox.information(self, "None", "Nothing to add.")
            return
        # Append
        with open(SERIALS_CSV_PATH, 'a', newline='') as f:
            writer = csv.writer(f)
            for s in added:
                writer.writerow([s])
        if added:           
            last_serial = int(added[-1])  # serials were str but numeric
            update_latest_serial(last_serial + 1)        
        self.refresh_table()
        QMessageBox.information(self, "Saved", f"Saved {len(added)} serials. They are now reserved.")
        


# === File: docs_export.py ===
from PyQt6.QtWidgets import *
from jobdata import JobData

class DocsExportStep(QWidget):
    def __init__(self, job: JobData):
        super().__init__()
        self.job = job
        layout = QVBoxLayout()
        layout.addWidget(QLabel("Export Docs/Archive Job"))
        pdf_btn = QPushButton("Export as PDF")
        pdf_btn.clicked.connect(lambda: QMessageBox.information(self, "PDF", "Job docs exported (mock)"))
        finish_btn = QPushButton("Mark Complete")
        finish_btn.clicked.connect(self.finish_job)
        layout.addWidget(pdf_btn)
        layout.addWidget(finish_btn)
        self.setLayout(layout)
    def finish_job(self):
        self.job.status = "Complete"
        QMessageBox.information(self, "Done", "Job marked complete (mock).")


# === File: encoding_checklist.py ===
from PyQt6.QtWidgets import *
from PyQt6.QtGui import QIntValidator, QRegularExpressionValidator
from PyQt6.QtWidgets import QCompleter
from PyQt6.QtCore import Qt, QDate, QStringListModel, QRegularExpression

from jobdata import JobData
from serial_tracker import reserve_serials
from job_folder import create_job_folders
from util import load_settings

import os
SETTINGS_DATA = load_settings()


# The new Encoding Checklist Tab (full update!):
class EncodingChecklistTab(QWidget):
    FIELD_ORDER = [
        'customer','job_ticket','part_num','customer_po','item',
        'inlay_type','label_size','qty','overage','upc',
        'labels_per_roll','rolls'
    ]
    FIELD_LABELS = {
        'customer': "Customer",
        'job_ticket': "Job Ticket #",
        'part_num': "Part Num",
        'customer_po': "Customer PO",
        'item': "Item",
        'inlay_type': "Inlay Type",
        'label_size': "Label Size",
        'qty': "QTY",
        'overage': "Overage",
        'upc': "UPC",
        'labels_per_roll': "Labels Per Roll",
        'rolls': "Rolls (Auto Calc)",
    }
    def __init__(self, job: JobData):
        super().__init__()
        self.job = job
        self.layout = QVBoxLayout()
        self.form = QFormLayout()
        self.fields = {}

        # TEXT FIELDS
        text_fields = ['customer', 'job_ticket', 'part_num', 'customer_po', 'item']
        for key in text_fields:
            line = QLineEdit()
            line.setMaxLength(64)
            self.form.addRow(self.FIELD_LABELS[key], line)
            self.fields[key] = line

        # Inlay Type dropdown (dynamic)
        self.inlay_combo = QComboBox()
        self.inlay_combo.setEditable(True)
        self.inlay_combo.addItems(SETTINGS_DATA["inlay_types"])
        self.form.addRow(self.FIELD_LABELS['inlay_type'], self.inlay_combo)
        self.fields['inlay_type'] = self.inlay_combo

        # Label Size dropdown with autocomplete (dynamic)
        self.labelsize_combo = QComboBox()
        self.labelsize_combo.setEditable(True)
        self.completer = QCompleter(SETTINGS_DATA["label_sizes"])
        self.completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
        self.labelsize_combo.setCompleter(self.completer)
        self.labelsize_combo.addItems(SETTINGS_DATA["label_sizes"])
        self.form.addRow(self.FIELD_LABELS['label_size'], self.labelsize_combo)
        self.fields['label_size'] = self.labelsize_combo

        combo_width = 160 
        self.inlay_combo.setFixedWidth(combo_width)
        self.labelsize_combo.setFixedWidth(combo_width)

        # QTY (numeric only, comma formatting)
        self.qty_field = QLineEdit()
        self.qty_field.setValidator(QIntValidator(0, 999999999))
        self.qty_field.setMaxLength(12)
        self.qty_field.textChanged.connect(lambda: self._format_commas_lineedit(self.qty_field))
        self.qty_field.textChanged.connect(self.auto_calc_rolls)
        self.form.addRow(self.FIELD_LABELS['qty'], self.qty_field)
        self.fields['qty'] = self.qty_field

        # Overage (allows numbers or %)
        self.overage_field = QLineEdit()
        re = QRegularExpression(r"^(\d+(,\d{3}){0,3}|(\d+%))?$")
        self.overage_field.setValidator(QRegularExpressionValidator(re))
        self.form.addRow(self.FIELD_LABELS['overage'], self.overage_field)
        self.fields['overage'] = self.overage_field

        # UPC (12 digits, numbers)
        self.upc_field = QLineEdit()
        self.upc_field.setMaxLength(12)
        re_upc = QRegularExpression(r"\d{0,12}")
        self.upc_field.setValidator(QRegularExpressionValidator(re_upc))
        self.form.addRow(self.FIELD_LABELS['upc'], self.upc_field)
        self.fields['upc'] = self.upc_field

        # Labels per roll / Rolls
        self.labels_per_roll_field = QLineEdit()
        self.labels_per_roll_field.setValidator(QIntValidator(1, 99999999))
        self.labels_per_roll_field.textChanged.connect(self.auto_calc_rolls)
        self.form.addRow(self.FIELD_LABELS['labels_per_roll'], self.labels_per_roll_field)
        self.fields['labels_per_roll'] = self.labels_per_roll_field

        self.rolls_label = QLabel("?")
        self.form.addRow(self.FIELD_LABELS['rolls'], self.rolls_label)
        self.fields['rolls'] = self.rolls_label

        # SERIAL LABEL (result display only)
        self.serial_label = QLabel("(Serials will be assigned when checklist is created)")
        self.form.addRow("Serials Reserved:", self.serial_label)

        # --- Create checklist button and checkbox ---
        self.make_db_chk = QCheckBox("Create folder and job database as well")
        self.make_db_chk.setChecked(True)
        self.create_btn = QPushButton("Create Checklist")
        self.create_btn.clicked.connect(self.handle_create_checklist)

        self.layout.addLayout(self.form)
        self.layout.addWidget(self.make_db_chk)
        self.layout.addWidget(self.create_btn)
        self.setLayout(self.layout)
        self.refresh()

    def _format_commas_lineedit(self, lineedit):
        txt = lineedit.text().replace(",", "")
        if not txt or not txt.isdigit():
            return
        val = int(txt)
        formatted = "{:,}".format(val)
        if lineedit.text() != formatted:
            lineedit.blockSignals(True)
            lineedit.setText(formatted)
            lineedit.blockSignals(False)

    def auto_calc_rolls(self):
        try:
            qty_val = int(self.qty_field.text().replace(",", ""))
            lbls = int(self.labels_per_roll_field.text().replace(",", ""))
            rolls = (qty_val + lbls - 1) // lbls if lbls > 0 else 0
            self.rolls_label.setText(str(rolls))
        except Exception:
            self.rolls_label.setText("?")

    def handle_create_checklist(self):
        # --- Validation rules ---
        # UPC: 12 digits, numeric
        upc = self.upc_field.text().strip()
        if len(upc) != 12 or not upc.isdigit():
            QMessageBox.warning(self, "UPC", "UPC must be exactly 12 digits (numeric only).")
            self.upc_field.setFocus()
            return
        # QTY check
        try:
            qty = int(self.qty_field.text().replace(",", "").strip())
        except Exception:
            QMessageBox.warning(self, "Missing", "Qty must be a number.")
            return
        # Overage check (accepts blank, number, or ##%)
        ov = self.overage_field.text().strip()
        if ov and not (ov.isdigit() or (ov.endswith("%") and ov[:-1].isdigit())):
            QMessageBox.warning(self, "Overage", "Overage must be blank, a number or percent (eg. 1000 or 10%).")
            self.overage_field.setFocus()
            return
        # Labels per roll check:
        if not self.labels_per_roll_field.text().replace(",", "").isdigit():
            QMessageBox.warning(self, "Labels Per Roll", "Labels Per Roll must be a number.")
            self.labels_per_roll_field.setFocus()
            return

        # All other fields
        values = {}
        for key in self.FIELD_ORDER:
            widget = self.fields.get(key)
            val = ""
            if isinstance(widget, QLineEdit):
                val = widget.text().strip()
            elif isinstance(widget, QComboBox):
                val = widget.currentText().strip()
            elif isinstance(widget, QLabel):
                val = widget.text().strip()
            values[key] = val

        # Get info for serial reserve and folder
        customer = values['customer']
        label_size = values['label_size']
        job_ticket = values['job_ticket']
        po = values['customer_po']
        date_str = QDate.currentDate().toString("yyyy-MM-dd")

        # SERIAL ALLOCATION (global tracker)
        start, stop = reserve_serials(job_ticket, customer, label_size, qty)
        self.serial_label.setText(f"{start:,} - {stop:,}")

        # Store in job/checklist_data
        self.job.checklist_data['serial_start'] = str(start)
        self.job.checklist_data['serial_stop'] = str(stop)

        # Folder/db: 
        if self.make_db_chk.isChecked():
            jdir = create_job_folders(customer, label_size, job_ticket, po, date_str)
            db_path = os.path.join(jdir, 'data', 'EPC_Database.xlsx')
            if not os.path.exists(db_path):
                try:
                    import pandas as pd
                    df = pd.DataFrame(columns=["EPC", "Serial", "UPC", "Date"])
                    df.to_excel(db_path, index=False)
                except Exception as ex:
                    QMessageBox.warning(
                        self, "Error", f"Unable to create database file:\n{ex}"
                    )
            QMessageBox.information(self, "Folders OK", f"Created dir:\n{jdir}")
        QMessageBox.information(self, "Serials Reserved", f"Serial range: {start} - {stop}")

        # Save main data fields
        for key in self.FIELD_ORDER:
            widget = self.fields.get(key)
            val = ""
            if isinstance(widget, QLineEdit):
                val = widget.text().strip()
            elif isinstance(widget, QComboBox):
                val = widget.currentText().strip()
            elif isinstance(widget, QLabel):
                val = widget.text().strip()
            self.job.checklist_data[key] = val

        self.job.checklist_data['start'] = str(start)
        self.job.checklist_data['stop'] = str(stop)

    def refresh(self):
        data = self.job.checklist_data
        # Set fields in UI (do this in PDF field order!)
        for key in self.FIELD_ORDER:
            val = data.get(key, "")
            widget = self.fields.get(key)
            if isinstance(widget, QLineEdit):
                widget.setText(str(val))
            elif isinstance(widget, QComboBox):
                idx = widget.findText(val)
                if idx >= 0:
                    widget.setCurrentIndex(idx)
                else:
                    widget.setCurrentText(str(val))
            elif isinstance(widget, QLabel):
                widget.setText(str(val))

# === File: jobdata.py ===
import datetime

class JobData:
    def __init__(self, name, code, qty, modules=None):   # <--- add the modules param & default
        self.name = name
        self.code = code
        self.qty = qty
        self.start_time = datetime.datetime.now()
        self.serials = []
        self.bartender_file = ""
        self.rolls = []
        self.status = "Initialized"
        self.checklist_data = {
            'customer': '',
            'job_ticket': '',
            'part_num': '',
            'customer_po': '',
            'item': '',
            'inlay_type': '',
            'label_size': '',
            'qty': '',
            'overage': '',
            'upc': '',
            'start': '',
            'stop': '',
            'labels_per_roll': '',
            'rolls': ''
        }
        # Store module selections (add this new attribute)
        self.modules = modules or {
            "show_checklist": True,
            "show_dbgen": True,
            "show_rolltracker": True
        }

