# ===== __init__.py =====



# ===== dashboard.py =====

# ===== dashboard.py =====

from PyQt6.QtWidgets import *
from PyQt6.QtGui import QFont
from PyQt6.QtCore import QTimer, Qt
from util import current_time_str
import random

# ---------- Dashboard ----------
class PrinterDetailDialog(QDialog):
    def __init__(self, printer_data):
        super().__init__()
        self.setWindowTitle(f"Details for {printer_data['printer_id']}")
        self.resize(400, 300)
        layout = QVBoxLayout()
        layout.addWidget(QLabel(f"Printer Name: {printer_data['printer_id']}"))
        printed = printer_data["pass_count"] + printer_data["fail_count"]
        layout.addWidget(QLabel(f"Total Printed: {printed}"))
        layout.addWidget(QLabel(f"Total Voided: {printer_data['fail_count']}"))
        error_pct = f"{(printer_data['fail_count']/printed * 100):.1f}%" if printed > 0 else "0%"
        layout.addWidget(QLabel(f"Quality Error %: {error_pct}"))
        layout.addWidget(QLabel(f"Last Update: {printer_data['last_event']}"))
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        layout.addWidget(close_btn)
        self.setLayout(layout)

class DashboardWidget(QWidget):
    def __init__(self, printer_data):
        super().__init__()
        self.all_printers = printer_data
        main_layout = QVBoxLayout()
        header_layout = QHBoxLayout()
        header_label = QLabel("Dashboard / Live Monitor")
        header_label.setStyleSheet("font-size: 16px; font-weight: bold;")
        header_layout.addWidget(header_label)
        header_layout.addStretch()
        self.interval_selector = QComboBox()
        self.interval_selector.addItems(["Live", "1 hour", "4 hours", "8 hours"])
        header_layout.addWidget(QLabel("Interval:"))
        header_layout.addWidget(self.interval_selector)
        main_layout.addLayout(header_layout)
        self.table = QTableWidget()
        self.table.setColumnCount(4)
        self.table.setHorizontalHeaderLabels(["Printer", "Printed", "Voided", "Error %"])
        self.table.verticalHeader().setVisible(False)
        self.table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        font = QFont()
        font.setPointSize(11)
        self.table.setFont(font)
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.table.verticalHeader().setDefaultSectionSize(30)
        self.table.cellDoubleClicked.connect(self.handle_row_click)
        main_layout.addWidget(self.table)
        self.setLayout(main_layout)
        self.populate_table()
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_table_data)
        self.timer.start(3000)
    def populate_table(self):
        printers = sorted(self.all_printers.keys())
        self.table.setRowCount(len(printers))
        for idx, pid in enumerate(printers):
            data = self.all_printers[pid]
            printed = data["pass_count"] + data["fail_count"]
            voided = data["fail_count"]
            error_pct = f"{(voided/printed * 100):.1f}%" if printed > 0 else "0%"
            self.table.setItem(idx, 0, QTableWidgetItem(pid))
            self.table.setItem(idx, 1, QTableWidgetItem(str(printed)))
            self.table.setItem(idx, 2, QTableWidgetItem(str(voided)))
            self.table.setItem(idx, 3, QTableWidgetItem(error_pct))
    def update_table_data(self):
        interval = self.interval_selector.currentText()
        multiplier = {"Live": 1, "1 hour": 1, "4 hours": 2, "8 hours": 3}.get(interval, 1)
        for pid in self.all_printers:
            data = self.all_printers[pid]
            data["pass_count"] += random.randint(0, 5 * multiplier)
            data["fail_count"] += random.randint(0, 3 * multiplier)
            data["last_event"] = current_time_str()
        self.populate_table()
    def handle_row_click(self, row, column):
        pid_item = self.table.item(row, 0)
        if pid_item:
            pid = pid_item.text()
            printer_data = self.all_printers.get(pid)
            if printer_data:
                dlg = PrinterDetailDialog(printer_data)
                dlg.exec()


# ===== job_list_item_widget.py =====

from PyQt6.QtWidgets import QWidget, QLabel, QPushButton, QHBoxLayout

class JobListItemWidget(QWidget):
    def __init__(self, job_name, remove_callback):
        super().__init__()
        layout = QHBoxLayout()
        self.label = QLabel(job_name)
        self.remove_btn = QPushButton("✖")  # Could use a trash icon or "X"
        self.remove_btn.setFixedSize(22, 22)
        self.remove_btn.setStyleSheet("QPushButton { border: none; color: #B00; }")
        layout.addWidget(self.label)
        layout.addStretch()
        layout.addWidget(self.remove_btn)
        self.setLayout(layout)
        # Wire up remove callback
        self.remove_btn.clicked.connect(remove_callback)

# ===== jobs_module.py =====

# ===== jobs_module.py =====

# === File: ui/jobs_module.py ===
from PyQt6.QtWidgets import (
    QWidget, QSplitter, QListWidget, QPushButton, QLabel,
    QHBoxLayout, QVBoxLayout, QMessageBox, QDialog, QFormLayout,
    QComboBox, QLineEdit, QSpinBox, QTabWidget, QCompleter
)
from PyQt6.QtCore import QThread, QObject, pyqtSignal, QTimer
from PyQt6.QtGui import QIntValidator

import os
import datetime

from data.jobdata import JobData
from workflow.encoding_checklist import EncodingChecklistTab
from database_tab import DatabaseTab
from workflow.database_generator import DatabaseGeneratorTab
from workflow.roll_tracker import RollTrackerStep
from workflow.bartender_step import BarTenderStep
from workflow.test_print import TestPrintStep
from workflow.docs_export import DocsExportStep
from ui.module_selector import ModuleSelectionDialog
from data.job_db import JobDB
from data.job_folder import get_job_dir
from util import get_all_customers, get_all_label_sizes, get_inlay_types

CUSTOMERS_ROOT = r"Z:\3 Encoding and Printing Files\Customers Encoding Files"


class JobFolderWorker(QObject):
    finished = pyqtSignal(str)
    error = pyqtSignal(str)

    def __init__(self, job_dir):
        super().__init__()
        self.job_dir = job_dir

    def run(self):
        try:
            for subdir in ("Print", "Data", "Roll Tracker", "Reports", "Checklist"):
                os.makedirs(os.path.join(self.job_dir, subdir), exist_ok=True)
            self.finished.emit(self.job_dir)
        except Exception as e:
            self.error.emit(str(e))


class JobsModuleWidget(QWidget):
    def __init__(self):
        super().__init__()

        # Database setup: use single file job DB
        self.job_db = JobDB()

        # UI setup
        split = QSplitter()
        # Left panel: job list and New Job button
        self.job_list = QListWidget()
        self.new_btn = QPushButton("New Job")
        self.new_btn.setMaximumWidth(150)
        left_layout = QVBoxLayout()

        # -- Active/Completed Toggle --
        self.show_completed = False
        self.toggle_btn = QPushButton("Show Completed Jobs")
        self.toggle_btn.setMaximumWidth(200)
        self.toggle_btn.clicked.connect(self.toggle_completed)
        left_layout.addWidget(self.toggle_btn)
        # --

        left_layout.addWidget(QLabel("All Jobs"))
        left_layout.addWidget(self.job_list)
        left_layout.addWidget(self.new_btn)
        left_panel = QWidget()
        left_panel.setLayout(left_layout)

        # Right panel: placeholder or workflow
        self.right_panel = QWidget()
        self.right_panel_layout = QVBoxLayout()
        self.right_panel_layout.addWidget(QLabel("No job selected."))
        self.right_panel.setLayout(self.right_panel_layout)

        split.addWidget(left_panel)
        split.addWidget(self.right_panel)
        split.setStretchFactor(1, 2)

        main_layout = QHBoxLayout()
        main_layout.addWidget(split)
        self.setLayout(main_layout)

        # State
        self.jobs = []

        # Initial load
        self.load_jobs_from_db()

        # Signals
        self.job_list.currentRowChanged.connect(self.select_job)
        self.new_btn.clicked.connect(self.new_job_dialog)

    def load_jobs_from_db(self):
        self.jobs.clear()
        self.job_list.clear()
        jobs_data = self.job_db.list_jobs()
        for jd in jobs_data:
            job = JobData(jd['job_name'], jd['job_ticket'], jd['qty'])
            job.db_id = jd['id']
            job.status = jd['status']
            job.folder_path = jd['folder_path']
            job.checklist_data = jd.get('checklist_data', {})
            self.jobs.append(job)
            # Add job based on toggle (active/completed)
            if ((not self.show_completed and job.status == 'active')
                or (self.show_completed and job.status == 'completed')):
                self.job_list.addItem(job.name)

    def select_job(self, row):
        # Clear right panel
        while self.right_panel_layout.count():
            item = self.right_panel_layout.takeAt(0)
            w = item.widget()
            if w:
                w.deleteLater()
        # Show selected job
        if 0 <= row < len(self.jobs):
            job = self.jobs[row]
            # If currently filtering for active/completed, the index maps only to that subset
            matched_jobs = [
                j for j in self.jobs
                if ((not self.show_completed and j.status == 'active')
                   or (self.show_completed and j.status == 'completed'))
            ]
            if 0 <= row < len(matched_jobs):
                job = matched_jobs[row]
                widget = SingleJobWorkflowWidget(job, self)
                self.right_panel_layout.addWidget(widget)
            else:
                self.right_panel_layout.addWidget(QLabel("No job selected."))
        else:
            self.right_panel_layout.addWidget(QLabel("No job selected."))

    def new_job_dialog(self, prefill=None):
        dlg = JobWizard(prefill, self)
        if dlg.exec() == QDialog.DialogCode.Accepted:
            data = dlg.get_data()
            if not data:
                return
            # Prepare job directory path
            date_str = datetime.datetime.now().strftime("%Y-%m-%d")
            job_dir = get_job_dir(
                data['customer'], data['label_size'],
                data['job_ticket'], data['customer_po'], date_str
            )
            # Create folders asynchronously
            self.create_job_folders_async(job_dir, lambda path: self.finish_job_creation(data, path))

    def create_job_folders_async(self, job_dir, callback):
        self.folder_thread = QThread()
        self.folder_worker = JobFolderWorker(job_dir)
        self.folder_worker.moveToThread(self.folder_thread)
        self.folder_thread.started.connect(self.folder_worker.run)
        self.folder_worker.finished.connect(lambda path: callback(path))
        self.folder_worker.finished.connect(self.folder_thread.quit)
        self.folder_worker.finished.connect(self.folder_worker.deleteLater)
        self.folder_worker.error.connect(self.on_folder_error)
        self.folder_thread.finished.connect(self.folder_thread.deleteLater)
        self.folder_thread.start()

    def finish_job_creation(self, data, folder_path):
        job_name = f"{data['customer']} - {data['job_ticket']} - {data['label_size']}"
        job = JobData(job_name, data['job_ticket'], data['qty'])
        job.checklist_data = data
        job.folder_path = folder_path
        job.status = 'active'
        job_id = self.job_db.add_job(job)
        job.db_id = job_id  # <-- Store row id
        self.jobs.append(job)
        self.load_jobs_from_db()  # Refresh list fully so new job is shown
        QMessageBox.information(
            self, "Folder Created",
            f"Job folder created at:\n{folder_path}\nJob added."
        )
        # DEFER selection to the event loop so the UI isn't blocked by widget construction
        QTimer.singleShot(0, lambda: self.job_list.setCurrentRow(self.job_list.count() - 1))

    def on_folder_error(self, err_msg):
        QMessageBox.critical(
            self, "Job Folder Error",
            f"Failed to create folders:\n{err_msg}"
        )

    def mark_job_completed(self, job):
        job.status = 'completed'
        self.job_db.update_job(job, job.db_id)
        self.load_jobs_from_db()

    def mark_job_active(self, job):
        job.status = 'active'
        self.job_db.update_job(job, job.db_id)
        self.load_jobs_from_db()

    def remove_job(self, job):
        if hasattr(job, 'db_id'):
            if QMessageBox.question(self, "Remove Job", f"Remove job '{job.name}' from database?") == QMessageBox.StandardButton.Yes:
                self.job_db.delete_job(job.db_id)
                self.load_jobs_from_db()

    def toggle_completed(self):
        self.show_completed = not self.show_completed
        if self.show_completed:
            self.toggle_btn.setText("Show Active Jobs")
        else:
            self.toggle_btn.setText("Show Completed Jobs")
        self.load_jobs_from_db()
        
class JobWizard(QDialog):
    def __init__(self, data: dict = None, parent=None):
        super().__init__(parent)
        self.setWindowTitle("New Job")
        form = QFormLayout(self)

        custs = get_all_customers()
        self.customer = QComboBox()
        self.customer.setEditable(True)
        self.customer.addItems(custs)
        self.customer.setCompleter(QCompleter(custs, self))
        form.addRow("Customer", self.customer)

        self.jobticket = QLineEdit(); form.addRow("Job Ticket", self.jobticket)
        self.partnum = QLineEdit(); form.addRow("Part Num", self.partnum)
        self.po = QLineEdit(); form.addRow("Customer PO", self.po)
        self.item = QLineEdit(); form.addRow("Item", self.item)

        inlays = get_inlay_types()
        self.inlay_type = QComboBox()
        self.inlay_type.setEditable(True)
        self.inlay_type.addItems(inlays)
        self.inlay_type.setCompleter(QCompleter(inlays, self))
        form.addRow("Inlay Type", self.inlay_type)

        all_label_sizes = get_all_label_sizes()
        self.label_size = QComboBox()
        self.label_size.setEditable(True)
        self.label_size.addItems(all_label_sizes)
        self.label_size.setCompleter(QCompleter(all_label_sizes, self))
        form.addRow("Label Size", self.label_size)

        self.qty = QLineEdit()
        self.qty.setValidator(QIntValidator(1,99999999)); form.addRow("QTY", self.qty)

        self.overage = QSpinBox()
        self.overage.setSuffix("%"); self.overage.setRange(0,100)
        form.addRow("Overage %", self.overage)

        self.upc = QLineEdit()
        self.upc.setMaxLength(15)
        self.upc.textChanged.connect(self._format_upc)
        form.addRow("UPC", self.upc)

        self.labels_per_roll = QLineEdit()
        self.labels_per_roll.setValidator(QIntValidator(1,99999999))
        self.labels_per_roll.textChanged.connect(self._calc_rolls)
        form.addRow("Labels Per Roll", self.labels_per_roll)

        self.rolls = QLabel("0")
        form.addRow("Rolls", self.rolls)

        btns = QHBoxLayout()
        done = QPushButton("Finish"); cancel = QPushButton("Cancel")
        btns.addWidget(done); btns.addWidget(cancel)
        form.addRow(btns)
        done.clicked.connect(self._finish)
        cancel.clicked.connect(self.reject)
        self.setLayout(form)

        self._result = None
        if data: self.fill(data)

    def _format_upc(self, txt):
        digits = "".join(c for c in txt if c.isdigit())[:12]
        pretty = ""
        for i, d in enumerate(digits):
            pretty += d
            if i in (2,5,8):
                pretty += " "
        self.upc.blockSignals(True)
        self.upc.setText(pretty)
        self.upc.blockSignals(False)

    def _calc_rolls(self):
        try:
            qty = int(self.qty.text())
            per = int(self.labels_per_roll.text())
            rolls = (qty + per - 1) // per
            self.rolls.setText(str(rolls))
        except:
            self.rolls.setText("0")

    def _finish(self):
        self.result = {
            "customer": self.customer.currentText(),
            "job_ticket": self.jobticket.text(),
            "part_num": self.partnum.text(),
            "customer_po": self.po.text(),
            "item": self.item.text(),
            "inlay_type": self.inlay_type.currentText(),
            "label_size": self.label_size.currentText(),
            "qty": int(self.qty.text().replace(",", "")),
            "overage": str(self.overage.value()),
            "upc": "".join(c for c in self.upc.text() if c.isdigit())[:12],
            "labels_per_roll": int(self.labels_per_roll.text().replace(",", "")),
            "rolls": int(self.rolls.text()),
        }
        self.accept()

    def get_data(self):
        return getattr(self, 'result', None)


class SingleJobWorkflowWidget(QWidget):
    def __init__(self, job: JobData, jobs_modwidget=None):
        super().__init__()
        layout = QVBoxLayout()
        self.tabs = QTabWidget()
        self.tabs.addTab(EncodingChecklistTab(job, jobs_modwidget), "Checklist")
        self.tabs.addTab(DatabaseTab(job), "Database")
        self.tabs.addTab(RollTrackerStep(job), "Roll Tracker")
        self.tabs.addTab(BarTenderStep(job), "BarTender")
        self.tabs.addTab(TestPrintStep(job), "Test Print & QC")
        self.tabs.addTab(DocsExportStep(job), "Docs/Export")
        layout.addWidget(self.tabs)
        self.setLayout(layout)
        
    def mark_job_completed(self, job):
        job.status = 'completed'
        self.job_db.update_job(job, job.db_id)
        self.load_jobs_from_db()



# ===== module_selector.py =====


# ===== module_selector.py =====

# module_selector.py

from PyQt6.QtWidgets import QDialog, QVBoxLayout, QCheckBox, QPushButton, QHBoxLayout, QLabel

class ModuleSelectionDialog(QDialog):
    """
    Dialog asking which workflow modules to use for a new job.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Select Workflow Modules")
        layout = QVBoxLayout()
        msg = QLabel(
            "Choose which modules to use for this job.\n"
            "You can choose any combination, but at least one."
        )
        layout.addWidget(msg)
        self.cb_checklist = QCheckBox("Encoding Checklist")
        self.cb_dbgen = QCheckBox("Database Generator")
        self.cb_rolltracker = QCheckBox("Roll Tracker")
        self.cb_checklist.setChecked(True)
        self.cb_dbgen.setChecked(False)
        self.cb_rolltracker.setChecked(False)
        layout.addWidget(self.cb_checklist)
        layout.addWidget(self.cb_dbgen)
        layout.addWidget(self.cb_rolltracker)
        btn_layout = QHBoxLayout()
        ok_btn = QPushButton("Start Workflow")
        cancel_btn = QPushButton("Cancel")
        btn_layout.addWidget(ok_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addLayout(btn_layout)
        self.setLayout(layout)
        ok_btn.clicked.connect(self.accept)
        cancel_btn.clicked.connect(self.reject)

    def get_selection(self):
        return {
            "show_checklist": self.cb_checklist.isChecked(),
            "show_dbgen": self.cb_dbgen.isChecked(),
            "show_rolltracker": self.cb_rolltracker.isChecked()
        }


# ===== reports.py =====

# ===== reports.py =====

from PyQt6.QtWidgets import *

class ReportsWidget(QWidget):
    def __init__(self):
        super().__init__()
        layout = QVBoxLayout()
        filter_layout = QHBoxLayout()
        filter_layout.addWidget(QLabel("Filter by Job/Date:"))
        self.filter_input = QLineEdit()
        filter_layout.addWidget(self.filter_input)
        layout.addLayout(filter_layout)
        csv_btn = QPushButton("Download CSV")
        csv_btn.clicked.connect(lambda: QMessageBox.information(self, "Download", "CSV downloaded (mock)."))
        pdf_btn = QPushButton("Download PDF")
        pdf_btn.clicked.connect(lambda: QMessageBox.information(self, "Download", "PDF downloaded (mock)."))
        layout.addWidget(csv_btn)
        layout.addWidget(pdf_btn)
        self.setLayout(layout)

# ===== settings.py =====

# ===== settings.py =====

from PyQt6.QtWidgets import *
from PyQt6.QtCore import Qt
from PyQt6.QtCore import QTime

from util import load_settings, save_settings, current_time_str,load_shift_settings, save_shift_settings
SETTINGS_DATA = load_settings()


class ShiftSettingsWidget(QWidget):
    def __init__(self):
        super().__init__()
        self.settings = load_shift_settings()
        layout = QFormLayout()
        self.day_start = QTimeEdit()
        self.day_start.setTime(QTime.fromString(self.settings['day']['start'], "HH:mm"))
        self.day_end = QTimeEdit()
        self.day_end.setTime(QTime.fromString(self.settings['day']['end'], "HH:mm"))
        self.night_start = QTimeEdit()
        self.night_start.setTime(QTime.fromString(self.settings['night']['start'], "HH:mm"))
        self.night_end = QTimeEdit()
        self.night_end.setTime(QTime.fromString(self.settings['night']['end'], "HH:mm"))
        layout.addRow("Day Shift Start:", self.day_start)
        layout.addRow("Day Shift End:", self.day_end)
        layout.addRow("Night Shift Start:", self.night_start)
        layout.addRow("Night Shift End:", self.night_end)
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(self.save)
        layout.addRow(save_btn)
        self.setLayout(layout)

    def save(self):
        self.settings['day']['start'] = self.day_start.time().toString("HH:mm")
        self.settings['day']['end'] = self.day_end.time().toString("HH:mm")
        self.settings['night']['start'] = self.night_start.time().toString("HH:mm")
        self.settings['night']['end'] = self.night_end.time().toString("HH:mm")
        save_shift_settings(self.settings)
        QMessageBox.information(self, "Saved", "Shift settings updated.")




class PrinterSettingsWidget(QWidget):
    def __init__(self, printer_data):
        super().__init__()
        self.printer_data = printer_data
        layout = QVBoxLayout()
        self.table = QTableWidget()
        self.table.setColumnCount(1)
        self.table.setHorizontalHeaderLabels(["Printer Name"])
        self.table.verticalHeader().setVisible(False)
        self.table.setEditTriggers(QTableWidget.EditTrigger.DoubleClicked |
                                    QTableWidget.EditTrigger.SelectedClicked)
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        layout.addWidget(self.table)
        add_layout = QHBoxLayout()
        self.new_printer_edit = QLineEdit()
        self.new_printer_edit.setPlaceholderText("New printer name")
        add_layout.addWidget(self.new_printer_edit)
        add_btn = QPushButton("Add Printer")
        add_btn.clicked.connect(self.add_printer)
        add_layout.addWidget(add_btn)
        layout.addLayout(add_layout)
        del_btn = QPushButton("Delete Selected")
        del_btn.clicked.connect(self.delete_selected)
        layout.addWidget(del_btn)
        save_btn = QPushButton("Save Changes")
        save_btn.clicked.connect(self.save_changes)
        layout.addWidget(save_btn)
        self.setLayout(layout)
        self.populate_table()
    def populate_table(self):
        printers = sorted(self.printer_data.keys())
        self.table.setRowCount(len(printers))
        for idx, pid in enumerate(printers):
            item = QTableWidgetItem(pid)
            item.setFlags(item.flags() | Qt.ItemFlag.ItemIsEditable)
            self.table.setItem(idx, 0, item)
    def add_printer(self):
        name = self.new_printer_edit.text().strip()
        if name:
            if name in self.printer_data:
                QMessageBox.warning(self, "Duplicate", "Printer already exists.")
            else:
                self.printer_data[name] = {"printer_id": name,
                                           "pass_count": 0,
                                           "fail_count": 0,
                                           "last_event": current_time_str()}
                self.populate_table()
                self.new_printer_edit.clear()
    def delete_selected(self):
        selected = self.table.selectedItems()
        if selected:
            for item in selected:
                pid = item.text()
                if pid in self.printer_data:
                    del self.printer_data[pid]
            self.populate_table()
    def save_changes(self):
        new_data = {}
        for row in range(self.table.rowCount()):
            item = self.table.item(row, 0)
            if item:
                new_name = item.text().strip()
                if new_name:
                    if new_name in self.printer_data:
                        new_data[new_name] = self.printer_data[new_name]
                    else:
                        new_data[new_name] = {"printer_id": new_name,
                                              "pass_count": 0,
                                              "fail_count": 0,
                                              "last_event": current_time_str()}
        self.printer_data.clear()
        self.printer_data.update(new_data)
        QMessageBox.information(self, "Saved", "Printer settings updated.")

class InlayTypeSettingsWidget(QWidget):
    def __init__(self, settings_data):
        super().__init__()
        self.settings_data = settings_data
        layout = QVBoxLayout()
        self.list_widget = QListWidget()
        self.refresh_list()
        layout.addWidget(QLabel("Inlay Types:"))
        layout.addWidget(self.list_widget)
        edit_layout = QHBoxLayout()
        self.new_input = QLineEdit()
        edit_layout.addWidget(self.new_input)
        add_btn = QPushButton("Add")
        add_btn.clicked.connect(self.add_item)
        edit_layout.addWidget(add_btn)
        layout.addLayout(edit_layout)
        edit_rename_layout = QHBoxLayout()
        self.rename_input = QLineEdit()
        edit_rename_layout.addWidget(self.rename_input)
        rename_btn = QPushButton("Rename")
        rename_btn.clicked.connect(self.rename_item)
        edit_rename_layout.addWidget(rename_btn)
        del_btn = QPushButton("Delete")
        del_btn.clicked.connect(self.delete_selected)
        edit_rename_layout.addWidget(del_btn)
        layout.addLayout(edit_rename_layout)
        self.setLayout(layout)
        self.list_widget.currentRowChanged.connect(self.select_item)
    def refresh_list(self):
        self.list_widget.clear()
        self.list_widget.addItems(self.settings_data["inlay_types"])
    def add_item(self):
        name = self.new_input.text().strip()
        if name and name not in self.settings_data["inlay_types"]:
            self.settings_data["inlay_types"].append(name)
            save_settings(self.settings_data)
            self.refresh_list()
            self.new_input.clear()
    def delete_selected(self):
        idx = self.list_widget.currentRow()
        if idx >= 0:
            del self.settings_data["inlay_types"][idx]
            save_settings(self.settings_data)
            self.refresh_list()
    def rename_item(self):
        idx = self.list_widget.currentRow()
        new_name = self.rename_input.text().strip()
        if idx >= 0 and new_name:
            self.settings_data["inlay_types"][idx] = new_name
            save_settings(self.settings_data)
            self.refresh_list()
            self.rename_input.clear()
    def select_item(self, row):
        if row >= 0:
            self.rename_input.setText(self.settings_data["inlay_types"][row])
        else:
            self.rename_input.clear()


class LabelSizeSettingsWidget(QWidget):
    def __init__(self, settings_data):
        super().__init__()
        self.settings_data = settings_data
        layout = QVBoxLayout()
        self.list_widget = QListWidget()
        self.refresh_list()
        layout.addWidget(QLabel("Label Sizes:"))
        layout.addWidget(self.list_widget)
        edit_layout = QHBoxLayout()
        self.new_input = QLineEdit()
        edit_layout.addWidget(self.new_input)
        add_btn = QPushButton("Add")
        add_btn.clicked.connect(self.add_item)
        edit_layout.addWidget(add_btn)
        layout.addLayout(edit_layout)
        edit_rename_layout = QHBoxLayout()
        self.rename_input = QLineEdit()
        edit_rename_layout.addWidget(self.rename_input)
        rename_btn = QPushButton("Rename")
        rename_btn.clicked.connect(self.rename_item)
        edit_rename_layout.addWidget(rename_btn)
        del_btn = QPushButton("Delete")
        del_btn.clicked.connect(self.delete_selected)
        edit_rename_layout.addWidget(del_btn)
        layout.addLayout(edit_rename_layout)
        self.setLayout(layout)
        self.list_widget.currentRowChanged.connect(self.select_item)
    def refresh_list(self):
        self.list_widget.clear()
        self.list_widget.addItems(self.settings_data["label_sizes"])
    def add_item(self):
        name = self.new_input.text().strip()
        if name and name not in self.settings_data["label_sizes"]:
            self.settings_data["label_sizes"].append(name)
            save_settings(self.settings_data)
            self.refresh_list()
            self.new_input.clear()
    def delete_selected(self):
        idx = self.list_widget.currentRow()
        if idx >= 0:
            del self.settings_data["label_sizes"][idx]
            save_settings(self.settings_data)
            self.refresh_list()
    def rename_item(self):
        idx = self.list_widget.currentRow()
        new_name = self.rename_input.text().strip()
        if idx >= 0 and new_name:
            self.settings_data["label_sizes"][idx] = new_name
            save_settings(self.settings_data)
            self.refresh_list()
            self.rename_input.clear()
    def select_item(self, row):
        if row >= 0:
            self.rename_input.setText(self.settings_data["label_sizes"][row])
        else:
            self.rename_input.clear()

class SettingsWidget(QWidget):
    def __init__(self, printer_data):
        super().__init__()
        tabs = QTabWidget()
        # File locations (stub)
        file_tab = QWidget()
        file_layout = QFormLayout()
        file_layout.addRow("CSV File Path:", QLineEdit("Z:\\Path\\to\\csv_data.csv"))
        file_layout.addRow("Template Folder:", QLineEdit("Z:\\Path\\to\\templates"))
        file_tab.setLayout(file_layout)
        tabs.addTab(file_tab, "File Locations")
        # Printer management tab
        printer_tab = PrinterSettingsWidget(printer_data)
        tabs.addTab(printer_tab, "Printers")
        # Inlay & label management
        inlay_tab = InlayTypeSettingsWidget(SETTINGS_DATA)
        labelsize_tab = LabelSizeSettingsWidget(SETTINGS_DATA)
        tabs.addTab(inlay_tab, "Inlay Types")
        tabs.addTab(labelsize_tab, "Label Sizes")
        
        shift_tab = ShiftSettingsWidget()   # <-- ADD THIS LINE
        tabs.addTab(shift_tab, "Shift Settings")
        
        roles_tab = QWidget()
        roles_layout = QVBoxLayout()
        roles_layout.addWidget(QLabel("User Roles (stubbed)"))
        roles_tab.setLayout(roles_layout)
        tabs.addTab(roles_tab, "User Roles")
        theme_btn = QPushButton("Toggle Dark/Light Theme")
        theme_btn.clicked.connect(lambda: QMessageBox.information(self, "Theme", "Theme toggled (mock)."))
        layout = QVBoxLayout()
        layout.addWidget(tabs)
        layout.addWidget(theme_btn)
        self.setLayout(layout)




# ===== config.py =====

# ===== config.py =====

import os
import json

SERIALS_CSV_PATH = r"Z:\3 Encoding and Printing Files\SERIALS_CSV_PATH.csv"
SETTINGS_JSON = r"settings_config.json"
DEFAULT_SETTINGS = {
    "inlay_types": ["Tageos EOS-300", "Avery AD-237", "Impinj MR6-P"],
    "label_sizes": ["2 x 1", "3 x 1", "4 x 2"]
}


# ===== database_tab.py =====

# ===== database_tab.py =====

# database_tab.py
from PyQt6.QtWidgets import *
from PyQt6.QtCore import QObject, pyqtSignal, QThread
import os
import pandas as pd




class DatabaseFileWorker(QObject):
    finished = pyqtSignal(str)
    error = pyqtSignal(str)

    def __init__(self, data_folder, db_path):
        super().__init__()
        self.data_folder = data_folder
        self.db_path = db_path

    def run(self):
        import pandas as pd
        import os
        try:
            os.makedirs(self.data_folder, exist_ok=True)
            df = pd.DataFrame(columns=["EPC", "Serial", "UPC", "Date"])
            df.to_excel(self.db_path, index=False)
            self.finished.emit(self.db_path)
        except Exception as e:
            self.error.emit(str(e))

class DatabaseTab(QWidget):
    def __init__(self, job):
        super().__init__()
        self.job = job
        layout = QVBoxLayout()
        self.info_label = QLabel("No database present.\nClick below to generate a new EPC database.")
        layout.addWidget(self.info_label)
        self.gen_btn = QPushButton("Generate Database File")
        self.gen_btn.clicked.connect(self.handle_generate_db)
        layout.addWidget(self.gen_btn)
        self.setLayout(layout)
        
        
        
    def handle_generate_db(self):
        job_folder = getattr(self.job, 'folder_path', None)
        if not job_folder:
            QMessageBox.warning(self, "Error", "No job folder found.")
            return
        data_folder = os.path.join(job_folder, "Data")
        db_path = os.path.join(data_folder, "EPC_Database.xlsx")
        self.progress = QProgressDialog(
            "Generating database file...", None, 0, 0, self)
        self.progress.setWindowModality(Qt.WindowModality.ApplicationModal)
        self.progress.setAutoClose(False)
        self.progress.setAutoReset(False)
        self.progress.show()

        self.worker_thread = QThread(self)
        self.worker = DatabaseFileWorker(data_folder, db_path)
        self.worker.moveToThread(self.worker_thread)
        self.worker_thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.on_db_gen_finished)
        self.worker.finished.connect(self.worker_thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.worker_thread.finished.connect(self.worker_thread.deleteLater)
        self.worker.error.connect(self.on_db_gen_error)
        self.worker_thread.start()

    def on_db_gen_finished(self, db_path):
        self.progress.close()
        QMessageBox.information(self, "Database Created", f"Database saved at:\n{db_path}")
        self.info_label.setText(f"Database created at: {db_path}")

    def on_db_gen_error(self, err):
        self.progress.close()
        QMessageBox.critical(self, "Database Error", f"Database generation failed:\n{err}")



# ===== main.py =====

# ===== main.py =====

import sys
import random
from PyQt6.QtWidgets import QApplication, QMainWindow, QTabWidget

from ui.dashboard import DashboardWidget
from ui.jobs_module import JobsModuleWidget
from ui.reports import ReportsWidget
from ui.settings import SettingsWidget


from util import current_time_str


class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("RFID Workflow Management Suite")
        self.resize(1000, 700)
        # Printer data (mock, globally shared)
        self.printer_data = {}
        for i in range(1, 11):
            pid = f"p{str(i).zfill(2)}"
            base_pass = 10 * random.randint(1, 5)
            self.printer_data[pid] = {
                "printer_id": pid,
                "pass_count": base_pass,
                "fail_count": random.randint(0, base_pass // 2),
                "last_event": current_time_str()
            }
        tabs = QTabWidget()
        tabs.addTab(DashboardWidget(self.printer_data), "Dashboard")
        tabs.addTab(JobsModuleWidget(), "Jobs")
        tabs.addTab(ReportsWidget(), "Reports")
        tabs.addTab(SettingsWidget(self.printer_data), "Settings")
        self.setCentralWidget(tabs)

def main():
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())

if __name__ == '__main__':
    main()


# ===== project_tree.py =====

import os
import tkinter as tk
from tkinter import filedialog, messagebox

def write_directory_tree(root_dir, out_path):
    with open(out_path, 'w', encoding='utf-8') as f:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Indent based on depth
            depth = dirpath[len(root_dir):].count(os.sep)
            indent = '    ' * depth
            f.write(f"{indent}{os.path.basename(dirpath)}/\n")
            for filename in filenames:
                f.write(f"{indent}    {filename}\n")

def select_and_write_tree():
    folder = filedialog.askdirectory(title="Select a folder to scan")
    if not folder:
        return
    out_path = os.path.join(folder, "directory_tree.txt")
    write_directory_tree(folder, out_path)
    messagebox.showinfo("Done", f"Directory tree saved to:\n{out_path}")

if __name__ == "__main__":
    root = tk.Tk()
    root.withdraw()  # Hide main window, show only file dialog
    select_and_write_tree()


# ===== util.py =====

# ===== util.py =====

import os, re
import csv
import datetime
from config import SERIALS_CSV_PATH, SETTINGS_JSON, DEFAULT_SETTINGS
import json
import ast
from PyQt6.QtCore import QObject, pyqtSignal, QThread



CUSTOMERS_ROOT = r"Z:\3 Encoding and Printing Files\Customers Encoding Files"
LABEL_SIZE_ROOT = r"Z:\3 Encoding and Printing Files\Encoding Ops\label_sizes.txt"

SHIFT_CONFIG_FILE = r"Z:\3 Encoding and Printing Files\Encoding Ops\Job list\shift_settings.json"
JOB_DB_DIR = r"Z:\3 Encoding and Printing Files\Encoding Ops\Job list"

# Default shift boundary config
DEFAULT_SHIFT_SETTINGS = {
    "day": {"start": "06:00", "end": "18:00"},
    "night": {"start": "18:00", "end": "06:00"}
}


class CustomerListWorker(QObject):
    finished = pyqtSignal(list)
    error = pyqtSignal(str)

    def run(self):
        try:
            from util import CUSTOMERS_ROOT
            import os
            customers = [d for d in os.listdir(CUSTOMERS_ROOT)
                         if os.path.isdir(os.path.join(CUSTOMERS_ROOT, d))]
            self.finished.emit(customers)
        except Exception as ex:
            self.error.emit(str(ex))


def load_shift_settings():
    if not os.path.exists(SHIFT_CONFIG_FILE):
        with open(SHIFT_CONFIG_FILE, "w") as f:
            json.dump(DEFAULT_SHIFT_SETTINGS, f, indent=2)
        return DEFAULT_SHIFT_SETTINGS.copy()
    with open(SHIFT_CONFIG_FILE, "r") as f:
        return json.load(f)

def save_shift_settings(data):
    with open(SHIFT_CONFIG_FILE, "w") as f:
        json.dump(data, f, indent=2)

def get_current_shift_and_dbdate(dt=None):
    """Determine current shift and its 'base date' for the DB file"""
    if dt is None:
        dt = datetime.datetime.now()
    settings = load_shift_settings()
    day_start = datetime.datetime.combine(dt.date(), datetime.datetime.strptime(settings["day"]["start"], "%H:%M").time())
    day_end   = datetime.datetime.combine(dt.date(), datetime.datetime.strptime(settings["day"]["end"], "%H:%M").time())
    night_start = datetime.datetime.combine(dt.date(), datetime.datetime.strptime(settings["night"]["start"], "%H:%M").time())

    if day_start <= dt < day_end:
        return ("day", day_start.date())
    else:
        # Night shift: if after night_start but before midnight, this day.
        # If after midnight but before day_start, assign *previous day's* "night shift"
        if dt >= night_start:
            return ("night", night_start.date())
        else:
            # before day_start (e.g. 03:00) -> previous night shift
            night_db_date = (dt - datetime.timedelta(days=1)).date()
            return ("night", night_db_date)


def get_all_customers():
    return [d for d in os.listdir(CUSTOMERS_ROOT) if os.path.isdir(os.path.join(CUSTOMERS_ROOT, d))]


def _load_label_sizes(path: str = LABEL_SIZE_ROOT) -> list[str]:
    """
    Read label-size definitions from *path*.

    * If the file starts with '[' we assume it’s a literal Python list and
      parse it with ast.literal_eval().
    * Otherwise we treat it as “one label per line”.
    """
    with open(path, "r", encoding="utf-8") as fh:
        raw = fh.read().strip()

    # Case 1 – literal Python list
    if raw.startswith("[") and raw.endswith("]"):
        try:
            data = ast.literal_eval(raw)
            if isinstance(data, list):
                return [str(item).strip() for item in data if str(item).strip()]
        except (SyntaxError, ValueError):
            pass  # fallback to next case

    # Case 2 – one label per line (ALWAYS return here if not list)
    return [line.strip() for line in raw.splitlines() if line.strip()]
        
        
def get_all_label_sizes():
    """
    Returns a sorted, deduplicated list of label sizes from file.
    """
    import os
    sizes = set()
    if os.path.isfile(LABEL_SIZE_ROOT):
        with open(LABEL_SIZE_ROOT, "r", encoding="utf-8") as f:
            data = f.read()
            for entry in data.split(","):
                val = entry.strip()
                # basic validation: must look like "int x int" or "float x float"
                import re
                if re.match(r"^\d+(\.\d+)?\s*x\s*\d+(\.\d+)?$", val):
                    sizes.add(re.sub(r"\s+", " ", val))  # normalize spaces
    return sorted(sizes)



def get_inlay_types():
    # Reads from 'popular_inlays.txt' in PROJECT ROOT
    with open(r"Z:\3 Encoding and Printing Files\Encoding Ops\label_types.txt") as f:
        return [line.strip() for line in f if line.strip()]



def current_time_str():
    return datetime.datetime.now().strftime("%H:%M:%S")

def load_settings():
    if not os.path.exists(SETTINGS_JSON):
        with open(SETTINGS_JSON, "w") as f:
            json.dump(DEFAULT_SETTINGS, f, indent=2)
        return DEFAULT_SETTINGS.copy()
    with open(SETTINGS_JSON, "r") as f:
        return json.load(f)

def save_settings(data):
    with open(SETTINGS_JSON, "w") as f:
        json.dump(data, f, indent=2)

def get_latest_serial():
    try:
        with open(SERIALS_CSV_PATH, "r", newline="") as f:
            reader = csv.reader(f)
            next(reader, None)
            row = next(reader, None)
            return int(row[0]) if row and row[0].isdigit() else 1
    except Exception:
        os.makedirs(os.path.dirname(SERIALS_CSV_PATH), exist_ok=True)
        with open(SERIALS_CSV_PATH, "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(['latest_serial'])
            writer.writerow(['1'])
        return 1

def update_latest_serial(new_serial):
    with open(SERIALS_CSV_PATH, "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["latest_serial"])
        writer.writerow([str(new_serial)])


# ===== __init__.py =====



# ===== bartender_step.py =====

from PyQt6.QtWidgets import *
from data.jobdata import JobData

class BarTenderStep(QWidget):
    def __init__(self, job: JobData):
        super().__init__()
        self.job = job
        layout = QFormLayout()
        self.template_path = QLineEdit()
        browse_template = QPushButton("Browse Template")
        browse_template.clicked.connect(self.browse_template)
        self.dest_path = QLineEdit()
        browse_dest = QPushButton("Browse Dest")
        browse_dest.clicked.connect(self.browse_dest)
        layout.addRow("Template File:", self.template_path)
        layout.addRow("", browse_template)
        layout.addRow("Destination Path:", self.dest_path)
        layout.addRow("", browse_dest)
        link_btn = QPushButton("Link File")
        link_btn.clicked.connect(self.link_file)
        layout.addRow(link_btn)
        self.setLayout(layout)
    def browse_template(self):
        path, _ = QFileDialog.getOpenFileName(self, "Select .btw Template", "", "BarTender Files (*.btw)")
        if path:
            self.template_path.setText(path)
    def browse_dest(self):
        path = QFileDialog.getExistingDirectory(self, "Select Destination")
        if path:
            self.dest_path.setText(path)
    def link_file(self):
        self.job.bartender_file = self.template_path.text()
        QMessageBox.information(self, "Success", "BarTender file linked (mock).")



# ===== database_generator.py =====

from PyQt6.QtWidgets import *
from PyQt6.QtCore import QObject, pyqtSignal, QThread

import csv
from config import SERIALS_CSV_PATH
from util import update_latest_serial
from data.jobdata import JobData




class SerialAppendWorker(QObject):
    finished = pyqtSignal(int)   # last serial written
    error = pyqtSignal(str)

    def __init__(self, serials):
        super().__init__()
        self.serials = serials

    def run(self):
        import csv
        from util import SERIALS_CSV_PATH, update_latest_serial
        try:
            with open(SERIALS_CSV_PATH, 'a', newline='') as f:
                writer = csv.writer(f)
                for s in self.serials:
                    writer.writerow([s])
            if self.serials:
                last_serial = int(self.serials[-1])
                update_latest_serial(last_serial + 1)
            self.finished.emit(last_serial)
        except Exception as ex:
            self.error.emit(str(ex))

class DatabaseGeneratorTab(QWidget):
    def __init__(self, job: JobData):
        super().__init__()
        self.job = job
        layout = QVBoxLayout()
        info_lbl = QLabel("Serial numbers in use are listed below.\n"
                          "Enter a new serial or range to check and append if unique.")
        layout.addWidget(info_lbl)
        self.table = QTableWidget()
        self.table.setColumnCount(1)
        self.table.setHorizontalHeaderLabels(['Serial Number'])
        self.table.verticalHeader().setVisible(False)
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        layout.addWidget(self.table)
        self.refresh_table()
        frm = QFormLayout()
        self.serial_input = QLineEdit()
        self.range_input = QLineEdit()
        save_btn = QPushButton("Add Serial(s)")
        save_btn.clicked.connect(self.try_save_serials)
        frm.addRow("Single Serial:", self.serial_input)
        frm.addRow("Or Serial Range (start-end):", self.range_input)
        frm.addRow(save_btn)
        layout.addLayout(frm)
        self.setLayout(layout)
    def refresh_table(self):
        serials = self.get_csv_serials()
        self.table.setRowCount(len(serials))
        for idx, s in enumerate(serials):
            item = QTableWidgetItem(s)
            self.table.setItem(idx, 0, item)
    @staticmethod
    def get_csv_serials():
        # Returns list of strings, skipping the header
        try:
            with open(SERIALS_CSV_PATH, newline='') as f:
                reader = csv.reader(f)
                next(reader, None)  # header
                return [x[0] for x in reader]
        except Exception:
            return []
    def try_save_serials(self):
        current_serials = set(self.get_csv_serials())
        added = []
        # Single
        val = self.serial_input.text().strip()
        if val:
            if val in current_serials:
                QMessageBox.warning(self, "Duplicate", f"Serial {val} already exists.")
                return
            added.append(val)
        # Range
        range_val = self.range_input.text().strip()
        if range_val:
            try:
                start, end = [x.strip() for x in range_val.split('-')]
                start, end = int(start), int(end)
                candidate = [str(s) for s in range(start, end+1)]
                duplicates = [s for s in candidate if s in current_serials]
                if duplicates:
                    QMessageBox.warning(self, "Duplicate", f"These serials already exist: {', '.join(duplicates)}")
                    return
                added.extend(candidate)
            except Exception:
                QMessageBox.warning(self, "Error", "Serial range format must be start-end (e.g. 1000-1010)")
                return
        if not added:
            QMessageBox.information(self, "None", "Nothing to add.")
            return
        # Append
        self.progress = QProgressDialog("Saving serials...", None, 0, 0, self)
        self.progress.setWindowModality(Qt.WindowModality.ApplicationModal)
        self.progress.show()
        self.serials_thread = QThread(self)
        self.serials_worker = SerialAppendWorker(added)
        self.serials_worker.moveToThread(self.serials_thread)
        self.serials_thread.started.connect(self.serials_worker.run)
        self.serials_worker.finished.connect(self.on_serial_save_finished)
        self.serials_worker.finished.connect(self.serials_thread.quit)
        self.serials_worker.finished.connect(self.serials_worker.deleteLater)
        self.serials_thread.finished.connect(self.serials_thread.deleteLater)
        self.serials_worker.error.connect(self.on_serial_save_error)
        self.serials_thread.start()
        
    def on_serial_save_finished(self, last_serial):
        self.progress.close()
        self.refresh_table()
        QMessageBox.information(self, "Saved", f"Saved serials. Up to {last_serial} now reserved.")

    def on_serial_save_error(self, msg):
        self.progress.close()
        QMessageBox.critical(self, "Error", f"Serial save error:\n{msg}")



# ===== docs_export.py =====

# ===== docs_export.py =====

from PyQt6.QtWidgets import *
from data.jobdata import JobData

class DocsExportStep(QWidget):
    def __init__(self, job: JobData):
        super().__init__()
        self.job = job
        layout = QVBoxLayout()
        layout.addWidget(QLabel("Export Docs/Archive Job"))
        pdf_btn = QPushButton("Export as PDF")
        pdf_btn.clicked.connect(lambda: QMessageBox.information(self, "PDF", "Job docs exported (mock)"))
        finish_btn = QPushButton("Mark Complete")
        finish_btn.clicked.connect(self.finish_job)
        layout.addWidget(pdf_btn)
        layout.addWidget(finish_btn)
        self.setLayout(layout)
    def finish_job(self):
        self.job.status = "Complete"
        QMessageBox.information(self, "Done", "Job marked complete (mock).")



# ===== encoding_checklist.py =====

# workflow/encoding_checklist.py

import os
import tempfile
import shutil
import time
import hashlib

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QPushButton, QHBoxLayout, QMessageBox, QDialog
)
from PyQt6.QtCore import QUrl, QTimer, Qt, QObject, pyqtSignal, QThread
from PyQt6.QtWebEngineWidgets import QWebEngineView

from data.jobdata import JobData
from util import load_settings

SETTINGS_DATA = load_settings()

class ChecklistPDFWorker(QObject):
    finished = pyqtSignal(str)        # emits output path on success
    error = pyqtSignal(str, str)      # emits error message, traceback

    def __init__(self, job, outpath, template_path):
        super().__init__()
        self.job = job
        self.outpath = outpath
        self.template_path = template_path

    def run(self):
        try:
            self._fill_and_save_pdf()
            self.finished.emit(self.outpath)
        except Exception as ex:
            import traceback
            self.error.emit(str(ex), traceback.format_exc())

    def _fill_and_save_pdf(self):
        import subprocess
        from pypdf import PdfReader, PdfWriter
        from pypdf.generic import NameObject

        checklist_dir = os.path.dirname(self.outpath)
        os.makedirs(checklist_dir, exist_ok=True)
        src = self.template_path
        dst = self.outpath
        reader = PdfReader(src)
        writer = PdfWriter()
        field_values = self.job.checklist_data.copy()
        fields = {k: str(field_values.get(k, "")) for k in reader.get_fields()}
        writer.append_pages_from_reader(reader)
        if "/AcroForm" in reader.trailer["/Root"]:
            writer._root_object.update({
                NameObject("/AcroForm"): reader.trailer["/Root"]["/AcroForm"]
            })
        else:
            raise RuntimeError("Template is missing /AcroForm! Cannot fill form.")
        writer.update_page_form_field_values(writer.pages[0], fields)
        with open(dst, "wb") as outf:
            writer.write(outf)

        # Try flatten (optional, can remove if you don't need it)
        flattened = dst.replace(".pdf", "_flat.pdf")
        flattened_success = False
        try:
            subprocess.run(["qpdf", "--flatten-annotations=all", dst, flattened], check=True)
            os.replace(flattened, dst)
            flattened_success = True
        except FileNotFoundError:
            pass
        except Exception:
            pass
        if not flattened_success:
            try:
                subprocess.run(["pdftk", dst, "output", flattened, "flatten"], check=True)
                os.replace(flattened, dst)
            except FileNotFoundError:
                pass
            except Exception:
                pass

class EncodingChecklistTab(QWidget):
    _temp_pdf_cache = {}  # class-wide cache: {source_pdf_path: temp_file_path}
    PDF_TEMPLATE = r"Z:\3 Encoding and Printing Files\Checklists & Spreadsheets\Encoding Checklist V4.1.pdf"
    PDFJS_VIEWER_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'static', 'pdfjs', 'viewer.html'))
    # ^--- Assumes [project]/static/pdfjs/viewer.html

    def __init__(self, job, jobs_modwidget=None):
        super().__init__()
        self.job = job
        self.jobs_modwidget = jobs_modwidget
        self.layout = QVBoxLayout(self)
        self._pdf_path = self._get_pdf_outpath()

        # PDF.js browser-based PDF preview
        self.web_pdf_view = QWebEngineView(self)
        self.layout.addWidget(self.web_pdf_view)

        self.btn_edit = QPushButton("Edit Checklist")
        self.btn_edit.clicked.connect(self._edit)
        hlayout = QHBoxLayout()
        hlayout.addStretch()
        hlayout.addWidget(self.btn_edit)
        self.layout.addLayout(hlayout)

        self.btn_ext = QPushButton("Open PDF in External Viewer")
        self.btn_ext.clicked.connect(self.open_external_pdf)
        self.layout.addWidget(self.btn_ext)

        QTimer.singleShot(0, self._init_pdf)

    def _init_pdf(self):
        generate_new = False
        if not os.path.exists(self._pdf_path):
            generate_new = True
        else:
            try:
                generated_mtime = os.path.getmtime(self._pdf_path)
                template_mtime = os.path.getmtime(self.PDF_TEMPLATE)
                if template_mtime > generated_mtime:
                    # Template is newer, regenerate
                    generate_new = True
            except Exception as e:
                print(f"Error checking template/output mtime: {e}")
                generate_new = True

        if generate_new:
            self._fill_and_save_pdf_async()
        else:
            self._show_pdf_in_browser()

    def _edit(self):
        """
        Show the edit dialog and, only if changes are confirmed, re-generate the checklist PDF and update the viewer.
        This assumes jobs_modwidget.new_job_dialog returns a modal dialog (QDialog).
        """
        if self.jobs_modwidget:
            # Defensive: handle different dialog return styles
            dialog = self.jobs_modwidget.new_job_dialog(prefill=self.job.checklist_data)
            result = None
            if isinstance(dialog, QDialog):
                result = dialog.exec()
            else:
                # It might directly update job.checklist_data and return None or something else,
                # but for legacy support, trigger PDF update regardless.
                result = QDialog.DialogCode.Accepted

            # If dialog accepted (or if no dialog object returned), regenerate and refresh PDF
            if result == QDialog.DialogCode.Accepted:
                # Optionally: fetch self.job.checklist_data from dialog if needed here
                self._fill_and_save_pdf_async()

    def _get_pdf_outpath(self):
        checklist_dir = os.path.join(self.job.folder_path, 'Checklist')
        return os.path.join(checklist_dir, "checklist.pdf")

    def _fill_and_save_pdf_async(self):
        print(f"Using template: {self.PDF_TEMPLATE}")
        self._show_loading_placeholder("Generating checklist PDF, please wait...")

        self.pdf_thread = QThread(self)
        self.pdf_worker = ChecklistPDFWorker(self.job, self._pdf_path, self.PDF_TEMPLATE)
        self.pdf_worker.moveToThread(self.pdf_thread)
        self.pdf_thread.started.connect(self.pdf_worker.run)
        self.pdf_worker.finished.connect(self._on_pdf_filled)
        self.pdf_worker.finished.connect(self.pdf_thread.quit)
        self.pdf_worker.finished.connect(self.pdf_worker.deleteLater)
        self.pdf_thread.finished.connect(self.pdf_thread.deleteLater)
        self.pdf_worker.error.connect(self._on_worker_error)
        self.pdf_thread.start()

    def _on_pdf_filled(self, outpath):
        # Wait briefly for IO sync, but do NOT recreate the widget; just load new PDF.
        for _ in range(10):
            if os.path.exists(outpath) and os.path.getsize(outpath) > 0:
                break
            time.sleep(0.05)
        else:
            self._show_loading_placeholder(f"PDF not ready at {outpath}")
            return
        self._show_pdf_in_browser()

    def _on_worker_error(self, msg, tb):
        self._remove_loading_placeholder()
        QMessageBox.critical(
            self, "Checklist PDF Error",
            f"Failed to fill checklist PDF. Error:\n{msg}\n\nTraceback:\n{tb}"
        )

    def _show_loading_placeholder(self, msg="Loading..."):
        self.web_pdf_view.setHtml(
            f"<html><body><h2 style='color:gray;text-align:center'>{msg}</h2></body></html>"
        )

    def _remove_loading_placeholder(self):
        self.web_pdf_view.setHtml("<html><body></body></html>")

    def _show_pdf_in_browser(self):
        # This does NOT close or recreate anything; just updates the viewer
        import uuid, shutil, os
        pdfjs_web_dir = r"Z:\pdfjs\web"
        viewer_html = os.path.join(pdfjs_web_dir, "viewer.html")

        if not os.path.exists(viewer_html):
            self.web_pdf_view.setHtml("<h3 style='color:red'>pdf.js <b>viewer.html</b> not found!</h3>")
            return
        
        src_pdf_path = self._pdf_path
        # Use a unique temp file for each preview to defeat browser cache!
        job_id = hashlib.md5(self._pdf_path.encode()).hexdigest()

        if not hasattr(self, '_pdf_cache'):
            self._pdf_cache = {}
        temp_pdf_path = self._pdf_cache.get(job_id)
        if not temp_pdf_path or not os.path.exists(temp_pdf_path) or os.path.getmtime(temp_pdf_path)<os.path.getmtime(self._pdf_path):
            temp_pdf_path = os.path.join(
                tempfile.gettempdir(), f"rfid_gui_tmp_checklist_preview_{job_id}.pdf"
            )
            try:
                shutil.copy2(self._pdf_path, temp_pdf_path)
                self._pdf_cache[job_id] = temp_pdf_path
            except Exception as e:
                self._show_loading_placeholder(f"Could not preview PDF:<br>{e}")
                return

        cache_bust = uuid.uuid4().hex
        viewer_url = QUrl.fromLocalFile(viewer_html)
        pdf_url = QUrl.fromLocalFile(temp_pdf_path).toString()
        viewer_url.setQuery(f"file={pdf_url}&cb={cache_bust}")
        self.web_pdf_view.setUrl(viewer_url)

    def open_external_pdf(self):
        import sys, subprocess
        path = self._pdf_path
        try:
            if sys.platform.startswith("win"):
                os.startfile(path)
            elif sys.platform.startswith("darwin"):
                subprocess.Popen(["open", path])
            else:
                subprocess.Popen(["xdg-open", path])
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not open PDF:\n{e}")

    def closeEvent(self, event):
        # Diagnostic: catch unexpected closes (for debugging)
        print(f"EncodingChecklistTab: Widget is closing.", flush=True)
        super().closeEvent(event)


# ===== roll_tracker.py =====


# ===== roll_tracker.py =====

from PyQt6.QtWidgets import *
from data.jobdata import JobData


class RollTrackerStep(QWidget):
    def __init__(self, job: JobData, segments=3):
        super().__init__()
        layout = QVBoxLayout()
        qty = job.qty
        segment_size = qty // segments if segments else qty
        layout.addWidget(QLabel(f"Total: {qty} | Rolls: {segments}"))
        for roll in range(1, segments+1):
            bar = QProgressBar()
            val = (segment_size / qty * 100) if roll < segments else (
                ((qty - (segments-1)*segment_size)/qty)*100)
            bar.setValue(int(val))
            bar.setFormat(f"Roll {roll}: {segment_size} labels")
            layout.addWidget(bar)
        export_btn = QPushButton("Export Roll Tracker")
        export_btn.clicked.connect(lambda: QMessageBox.information(self, "PDF", "Exported roll tracker (mock)"))
        layout.addWidget(export_btn)
        self.setLayout(layout)

# ===== test_print.py =====

from PyQt6.QtWidgets import *
from data.jobdata import JobData
import random

class TestPrintStep(QWidget):
    def __init__(self, job: JobData):
        super().__init__()
        layout = QVBoxLayout()
        layout.addWidget(QLabel("Test Print & Signoff"))
        print_btn = QPushButton("Print 5")
        print_btn.clicked.connect(self.print_labels)
        layout.addWidget(print_btn)
        self.result_list = QListWidget()
        layout.addWidget(self.result_list)
        sign_btn = QPushButton("Digital Signoff")
        sign_btn.clicked.connect(self.sign_off)
        layout.addWidget(sign_btn)
        self.setLayout(layout)
    def print_labels(self):
        self.result_list.clear()
        for i in range(5):
            self.result_list.addItem(f"Label {i+1}: EPC {random.randint(10000,99999)} - PASS")
        QMessageBox.information
        QMessageBox.information(self, "Printed", "Test print (mock)")
    def sign_off(self):
        QMessageBox.information(self, "Signoff", "Test print signed off (mock)")


# ===== __init__.py =====



# ===== job_db.py =====

# data/job_db.py

import sqlite3
import os
import json

JOBS_DB_PATH = os.path.abspath(
    os.path.join(os.path.dirname(__file__), "..", "jobs_db", "jobs.db")
)
os.makedirs(os.path.dirname(JOBS_DB_PATH), exist_ok=True)

def get_db_path():
    return JOBS_DB_PATH

class JobDB:
    def __init__(self, db_path=None):
        self.db_path = db_path or get_db_path()
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
        self.conn = sqlite3.connect(self.db_path)
        self.ensure_tables()

    def ensure_tables(self):
        c = self.conn.cursor()
        c.execute("""
            CREATE TABLE IF NOT EXISTS jobs (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                job_name TEXT,
                job_ticket TEXT,
                customer TEXT,
                label_size TEXT,
                qty INTEGER,
                created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                status TEXT,
                checklist_json TEXT,
                folder_path TEXT
            )""")
        self.conn.commit()

    def add_job(self, job):
        c = self.conn.cursor()
        c.execute("""INSERT INTO jobs
                        (job_name, job_ticket, customer, label_size, qty, status, checklist_json, folder_path)
                     VALUES (?, ?, ?, ?, ?, ?, ?, ?)""",
                  (job.name, job.code, job.checklist_data.get('customer', ''),
                   job.checklist_data.get('label_size', ''), job.qty,
                   getattr(job, 'status', 'active'),  # Default: active
                   json.dumps(getattr(job, 'checklist_data', {})),
                   getattr(job, 'folder_path', '')))
        self.conn.commit()
        return c.lastrowid

    def update_job(self, job, job_id):
        c = self.conn.cursor()
        c.execute("""UPDATE jobs SET
                            status=?, checklist_json=?, folder_path=?
                     WHERE id=?""",
                  (getattr(job, 'status', 'active'),
                   json.dumps(getattr(job, 'checklist_data', {})),
                   getattr(job, 'folder_path', ''),
                   job_id
                  ))
        self.conn.commit()

    def delete_job(self, job_id):
        c = self.conn.cursor()
        c.execute("DELETE FROM jobs WHERE id = ?", (job_id,))
        self.conn.commit()

    def list_jobs(self):
        c = self.conn.cursor()
        c.execute("SELECT id, job_name, job_ticket, customer, label_size, qty, status, folder_path, checklist_json FROM jobs")
        rows = c.fetchall()
        jobs = []
        for r in rows:
            jobs.append({
                "id": r[0],
                "job_name": r[1],
                "job_ticket": r[2],
                "customer": r[3],
                "label_size": r[4],
                "qty": r[5],
                "status": r[6],
                "folder_path": r[7],
                "checklist_data": json.loads(r[8] if r[8] else '{}')
            })
        return jobs

# ===== job_folder.py =====


# ===== job_folder.py =====

# file: data/job_folder.py
import os

def get_job_dir(customer, label_size, job_ticket, po, date_str):
    base_path = r"Z:\3 Encoding and Printing Files\Customers Encoding Files"
    cust_dir  = os.path.join(base_path, customer)
    size_dir  = os.path.join(cust_dir,   label_size)
    job_name  = f"{date_str} - {po} - {job_ticket}"
    return os.path.join(size_dir, job_name)




# ===== jobdata.py =====

# ===== jobdata.py =====


# file: data/jobdata.py

import datetime


class JobData:
    def __init__(self, name, code, qty, modules=None):   # <--- add the modules param & default
        self.db_id = None
        self.name = name
        self.code = code
        self.qty = qty
        self.start_time = datetime.datetime.now()
        self.serials = []
        self.bartender_file = ""
        self.rolls = []
        self.status = "Initialized"
        self.checklist_data = {
            'customer': '',
            'job_ticket': '',
            'part_num': '',
            'customer_po': '',
            'item': '',
            'inlay_type': '',
            'label_size': '',
            'qty': '',
            'overage': '',
            'upc': '',
            'start': '',
            'stop': '',
            'labels_per_roll': '',
            'rolls': ''
        }
        # Store module selections (add this new attribute)
        self.modules = modules or {
            "show_checklist": True,
            "show_dbgen": True,
            "show_rolltracker": True
        }


# ===== serial_tracker.py =====

# ===== serial_tracker.py =====

# serial_tracker.py

import csv, os, datetime

SERIAL_TRACKER_CSV = r"Z:\3 Encoding and Printing Files\Operations\serial_tracker.csv"

def get_next_available_serial():
    if not os.path.exists(SERIAL_TRACKER_CSV):
        return 1
    with open(SERIAL_TRACKER_CSV, newline='', encoding='utf-8') as f:
        rdr = list(csv.DictReader(f))
        if not rdr:
            return 1
        return int(rdr[-1]['next_serial'])

def reserve_serials(job_ticket, customer, label_size, qty):
    start = get_next_available_serial()
    stop = start + qty - 1
    next_serial = stop + 1
    row = {
        "date": datetime.datetime.now().strftime('%Y-%m-%d'),
        "job_ticket": job_ticket,
        "customer": customer,
        "label_size": label_size,
        "serial_start": start,
        "serial_stop": stop,
        "next_serial": next_serial
    }
    file_exists = os.path.exists(SERIAL_TRACKER_CSV)
    with open(SERIAL_TRACKER_CSV, 'a', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, fieldnames=list(row.keys()))
        if not file_exists:
            writer.writeheader()
        writer.writerow(row)
    return (start, stop)

